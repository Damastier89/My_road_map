# Базовые принципы проектирования

# Basic

- [Coupling (связывание)](#coupling)
- [Cohesion (сплочённость)](#cohesion)
- [Simplicity (простота и лёгкость)](#simplicity)
- [DRY](#dry)
- [Separation of concerns (разделение ответственности)](#separation-of-concerns)
- [Cross-cutting concerns (сквозные модули)](#cross-cutting-concerns)
- [Coroutine (сопрограмма)](#coroutine)

`Абстрагирование` — это процесс выделения общих свойств и характеристик объекта, избавляясь от излишней информации. В проектировании это помогает сосредоточиться на сути проблемы и создавать более универсальные решения. Например, когда мы говорим о "транспортном средстве", мы можем иметь в виду и машину, и велосипед, абстрагируясь от конкретных особенностей каждого из них.

`Абстракция` — это концепция, связанная с выделением важной информации и игнорированием менее значительной. Это позволяет работать с более комплексными системами, создавая упрощённые модели. Например, в программировании абстракция может быть реализована через интерфейсы, которые определяют поведение классов, не отражая их конкретную реализацию.

`Инкапсуляция` — это принцип, который подразумевает ограничение доступа к внутренним данным и методам объекта. Это помогает защитить данные от несанкционированного доступа и неизменности, создавая «чёрный ящик», который управляет своими внутренними состояниями и позволяет взаимодействовать только через определённые методы. Например, в классе может быть приватное поле, к которому можно получить доступ только через специальные методы (геттеры и сеттеры).

`Скрытие информации` — это близкий концепт к инкапсуляции, который фокусируется на том, чтобы скрывать детали реализации от пользователей. Это означает, что пользователи объекта не должны беспокоиться о том, как именно он работает внутри, а только о том, какие операции они могут с ним выполнять. Таким образом, можно изменять внутреннюю логику без влияния на внешний интерфейс.

## Coupling

`Coupling` (связывание) в контексте программирования и разработки программного обеспечения — это степень зависимости между различными модулями или компонентами системы. Чем меньше зависимостей между модулями, тем легче их менять, тестировать и поддерживать.

Существует несколько уровней связывания:

- Низкая связь (Loose Coupling) — модули независимы друг от друга и взаимодействуют через четко определенные интерфейсы.
- Высокая связь (Tight Coupling) — модули сильно зависят друг от друга, что усложняет их замену и тестирование.

Абстрагирование помогает снизить степень связывания, создавая общий интерфейс или контракт, который скрывает детали реализации. Таким образом, модули могут взаимодействовать друг с другом без необходимости знать, как работает тот или иной компонент. Это приводит к улучшенной гибкости, повторному использованию кода и облегчению изменений в будущем.

[Вернуться к началу статьи](#basic)

---

## Cohesion

`Cohesion` (сплочённость) — это мера того, насколько связанные и взаимозависимые элементы внутри одного модуля или компонента. Чем выше сплочённость, тем больше задач или функций выполняет модуль в одном контексте, что облегчает понимание и поддержку кода.

Типы сплочённости варьируются от низкой до высокой:

- Низкая сплочённость (например, модули, выполняющие множество несвязанных функций).
- Высокая сплочённость (например, модули, отвечающие за одну конкретную задачу или функциональность).

Хотя сплочённость и связывание (coupling) рассматриваются в контексте проектирования программного обеспечения, они не являются прямыми обратными величинами. Напротив:

Высокая сплочённость в модуле обычно ведет к низкой связи с другими модулями. То есть, чем более связаны функции внутри модуля (высокая сплочённость), тем меньше вероятно, что он будет сильно зависеть от других модулей (низкая связь).

[Вернуться к началу статьи](#basic)

---

## Simplicity

> В докладе Ричарда Хики "Simple Made Easy" он подробно рассматривает различие между двумя концепциями: "простота" (simple) и "лёгкость" (easy).

1. Простота (Simple)

- Простота подразумевает, что решение или система имеют ясную и понятную структуру. Они свободны от излишних сложностей и имеют четкие, легко понимаемые компоненты.
- Простота зачастую требует глубокого понимания предметной области и более строгих решений, которые могут быть сложнее в реализации, но более устойчивыми и долговечными в будущем.

2. Лёгкость (Easy)

- Лёгкость, напротив, связана с тем, насколько просто что-то сделать или понять. Это может означать, что данная система или решение имеют много удобств и «плоских» возможностей, которые делают их легкими для использования, но могут скрывать внутренние сложности.
- Лёгкость может привести к созданию систем с скрытой сложностью, что может вызвать проблемы в дальнейшем, когда требуется поддержка или расширение.

3. Зачем стремиться к простоте?

- Стремление к простоте важно, потому что простые системы легче поддерживать, расширять и объяснять.
- Простота способствует созданию более надежных и понятных архитектур, которые менее подвержены ошибкам. Они легче тестируются и имеют более высокую степень предсказуемости.
- В долгосрочной перспективе простота может оказаться более эффективной, поскольку использование легких, но сложных в основе решений может привести к неоправданным затратам времени и ресурсов.
  Простота — это концепция, которая требует более глубокого анализа и иногда более трудных решений, но результатом становится более устойчивый и эффективный код.

Принцип `KISS` (Keep It Simple, Stupid) — это философия, которая подчеркивает важность простоты в дизайне систем и решений. Основная идея этого принципа заключается в том, что вещи должны быть максимально простыми и понятными, и избегать ненужной сложности.

- `Простота в решениях`: Сложные решения не всегда являются лучшими. Старайтесь находить простые и элегантные способы решения задач.

- `Понятность`: Код и системы должны быть понятными не только для их авторов, но и для других разработчиков. Это упрощает поддержку и расширение проекта в будущем.

- `Минимализм`: Исключите все, что не является необходимым для выполнения функции. Избыточные особенности и излишняя функциональность могут вести к путанице и ошибкам.

- `Обратная сторона сложности`: Простота помогает избежать возникновения скрытых проблем, которые могут быть связаны с чрезмерно сложными решениями.

### Когда абстрагирование противоречит KISS?

1. Сложные абстракции: Когда абстракция становится слишком сложной или многослойной, это может затруднить понимание системы. Если пользователи не могут понять, как взаимодействовать с абстракцией, это уже противоречит принципу KISS.

2. Избыточное абстрагирование: Если разработчики создают абстракции для каждой маленькой детали или функции, система может стать перегруженной. Это может привести к избыточности и усложнению, вместо того чтобы сделать ее проще.

3. Сложные интерфейсы: Если абстракция требует сложных интерфейсов или форматов для взаимодействия, это может сделать использование системы менее интуитивным и сложным для пользователей, что также противоречит KISS.

### Почему наследование может приводить к нарушению KISS?

`Наследование` — это один из основных принципов объектно-ориентированного программирования (ООП), который позволяет создавать новые классы на основе уже существующих. Хотя наследование может быть полезным, оно также может приводить к нарушению принципа KISS (Keep It Simple, Stupid)

1. Сложность и запутанность: Когда иерархия классов становится слишком глубокой или сложной, это может привести к путанице и затруднить понимание кода. Разработчики могут тратить больше времени на изучение структуры, чем на решение конкретной проблемы.

2. Трудности с изменениями: Изменения в родительском классе могут повлиять на множество дочерних классов. Если разработчик вносит изменения в родительский класс, это может неожиданно вызвать ошибки или проблемы в дочерних классах, что увеличивает риск и усложняет поддержку.

3. Увеличение зависимости: Наследование создает зависимость между классами. Это может затруднить повторное использование кода и привести к жестким связям, которые усложняют модификацию и адаптацию системы.

### Может ли полиморфизм приводить к нарушению KISS?

Да, полиморфизм, как и наследование, также может привести к нарушению принципа KISS (Keep It Simple, Stupid) в некоторых случаях.

1. Сложная реализация: Когда полиморфизм используется через множество реализаций интерфейсов и абстрактных классов, это может создать сложные структуры, которые трудно понять и поддерживать. Разработчики могут столкнуться с трудностями в отслеживании, какие реализации применяются в различных контекстах.

2. Увеличение количества классов: Полиморфизм может привести к созданию множества классов для реализации различных вариаций поведения. Это может усложнить систему и сделать её более громоздкой, затрудняя понимание и поддержку кода.

3. Сложные интерфейсы: Если интерфейсы и абстрактные классы содержат много методов, которые должны быть реализованы, это может привести к усложнению кода, если реализация каждого метода требует значительных усилий.

### В чём заключается принцип YAGNI? Как он соотносится с принципом KISS?

Принцип `YAGNI` (You Aren't Gonna Need It) гласит, что разработчики не должны добавлять функциональность в систему до тех пор, пока она не станет необходимой. Этот принцип подчеркивает важность разработки только той функциональности, которая действительно требуется в данный момент, а не предполагаемой или потенциальной в будущем.

Основные аспекты принципа YAGNI:

- `Избежание избыточности`: Необходимо избегать избыточного кода и функциональности, которые могут усложнить проект и затруднить поддержку.

- `Упрощение разработки`: Разработчики могут сосредоточиться на текущих потребностях и быстро реагировать на изменения, не отрываясь на предстоящие возможные требования.

- `Упрощение тестирования`: Меньшее количество функций делает тестирование более управляемым и позволяет легче находить и исправлять ошибки.

- `Экономия времени и ресурсов`: Разработка ненужной функциональности может затянуть сроки проекта и увеличить затраты на поддержку.

Соотношение `YAGNI` с принципом `KISS`.

Принцип KISS (Keep It Simple, Stupid) и YAGNI взаимосвязаны и дополняют друг друга:

- `Схожесть в подходе`: Оба принципа акцентируют внимание на важности простоты в разработке и избегания лишнего. Они помогают уменьшить сложность системы и делают её более понятной как для разработчиков, так и для пользователей.

- `Национальные цели`: KISS направлен на создание простых и понятных решений, тогда как YAGNI акцентирует внимание на том, чтобы не добавлять функциональность, которая не требуется в данный момент.

- `Поддержка качества кода`: Используя оба принципа, разработчики могут создавать более поддерживаемый и адаптивный код, который легче модифицировать и расширять по мере необходимости.

[Вернуться к началу статьи](#basic)

---

## DRY

Принцип `DRY (Don't Repeat Yourself)` в программировании и разработке программного обеспечения гласит, что информация и логика должны быть сконцентрированы в одном месте. Основная идея этого принципа заключается в том, чтобы избежать дублирования кода и данных, что приводит к упрощению поддержки, улучшению читаемости и уменьшению вероятности ошибок.

### Как принцип DRY связан с Cohesion?

- Когда мы применяем принцип DRY, мы часто упрощаем структуры кода, что может привести к повышению сплочённости. Избегая дублирования, мы создаем модули и функции, которые более четко определены и более связаны с конкретными задачами.
- Хорошо спроектированные модули с высокой сплочённостью, как правило, лучше соответствуют принципу DRY, так как они реализуют один набор функций и избегают повторения.

### Как принцип DRY связан с принципом SRP (Single Responsibility Principle)?

Принцип `SRP`: Принцип единственной ответственности предполагает, что каждый модуль или класс должен иметь одну, четко определенную ответственность. То есть он должен выполнять только одну задачу или функцию, что упрощает понимание, поддержку и тестирование этого кода.

- Когда классы и модули следуют принципу SRP, они становятся более четко определенными и специализированными, что уменьшает вероятность дублирования кода. Например, если каждый класс отвечает только за свою задачу, то логика, связанная с этой задачей, вероятно, не будет дублироваться в разных классах. Это способствует соблюдению принципа DRY.
- С другой стороны, соблюдение принципа DRY может также помочь в реализации SRP, так как уменьшение дублирования может привести к выделению общих функций и логики в отдельные модули или классы, которые затем отвечают за свои специализированные задачи.

### Почему принцип DRY неразрывно связан с SPOT (Single point of truth)?

Принцип `SPOT`: Этот принцип гласит, что каждая единица данных (или логики) должна иметь одно, четкое и недвусмысленное место хранения. В идеале, если вам нужна информация, вы должны получать ее из одного источника, а не из множества мест. Это помогает избежать рассинхронизации данных и делает обработку информации более простой и понятной.

- Когда вы соблюдаете принцип DRY, вы стремитесь создать единую точку хранения логики или данных, тем самым реализуя принцип SPOT. Если вы избегаете дублирования, то каждая логика или данные будут находиться в одном месте, что обеспечит единую правду для всей системы.
- Принцип SPOT помогает поддерживать принцип DRY, так как наличие единственной точки хранения данных упрощает их управление и изменение. Когда данные или логика находятся в одном месте, это уменьшает вероятность необходимости дублировать код или информацию, что в свою очередь поддерживает принцип DRY.

### Какие есть примеры дублирования кода, которые не нарушают DRY?

- Логика различных классов: Например, два класса могут реализовывать похоже функциональность, но с использованием разных данных или методов. Если код написан в разных классах и выполняет разные задачи, это может быть допустимо, даже если он выглядит схоже. В таком случае лучше использовать наследование или составление для избежания дублирования. 🐍

- Сторонние библиотеки/фреймворки: Использование повторяющегося кода в сторонних библиотеках, которые вы не контролируете. В этом случае вы можете использовать общедоступный код, и его дублирование не считается нарушением DRY, поскольку вы не можете (и не должны) изменять библиотеку.

- Код, зависящий от контекста: Например, код, требующий различных настроек или конфигураций, может выглядеть похоже, но обеспечивать совершенно разную функциональность в зависимости от контекста. Так, если вы строите разные компоненты, которые требуют схожей структуры, это может быть приемлемым.

- Копирование для тестирования: При написании тестов иногда требуется скопировать некоторый код для тестирования различных сценариев. В таких случаях дублирование может быть оправданным, если это помогает улучшить качество кода.

- Примеры кода в документации: Иногда может потребоваться повторить куски кода в документации или обучающих материалах для ясности. Это не считается нарушением принципа DRY, так как цель здесь - обучение и разъяснение.

### Какие есть примеры копирования кода бизнес-логики, которые также не нарушают DRY?

- Разные контексты или приложения: Если у вас есть два разных приложения, которые выполняют схожие бизнес-операции, но в разных контекстах, может быть оправдано копирование кода. Например, если одно приложение обрабатывает заказы, а другое — возвраты, и они используют одну и ту же основную логику расчета цен, но с различными параметрами.

- Изолированные модули: В микросервисной архитектуре один сервис может дублировать бизнес-логику другого, если у них разные требования или данные. Например, в сервисах управления пользователями и платежами может потребоваться повторять логику аутентификации, но в то же время каждый сервис может иметь свой контекст.

- Использование шаблонов проектирования: Некоторые шаблоны проектирования, такие как Стратегия или Шаблон, могут потребовать копирование повторяющейся логики в разные классы или модули. Это может быть оправданным, если помогает улучшить модульность и поддерживаемость.

- Временные решения: Иногда можно временно копировать бизнес-логику для обеспечения интероперабельности компонентов системы. Например, при миграции системы можно временно дублировать логику в старом и новом коде, чтобы обеспечить плавный переход.

- Учебные примеры и документация: В учебных курсах или документации может потребоваться продублировать бизнес-логику для демонстрации, как работает система. Это помогает читателю лучше понять концепции без необходимости глубокого изучения кода.

### Как следование принципу DRY может привести к нарушению KISS?

> Следование принципу DRY подразумевает, что одинаковый код не должен повторяться. Это может привести к созданию общих абстракций или библиотек, которые пытаются охватить все возможные сценарии использования. В результате может возникнуть чрезмерная сложность в коде, так как разработчики начинают пытаться учесть все возможные варианты, что затрудняет понимание и поддержку кода. Это может нарушить принцип KISS, который призывает делать код простым и понятным.

> Например, если разработчик создаёт универсальную функцию для обработки данных, которая пытается учесть множество различных форматов и сценариев, она может быть очень сложной и трудно понимаемой. Вместо этого проще было бы создать несколько специализированных функций, каждая из которых решает определённую задачу, что укладывается в рамки KISS.

### Как следование принципу DRY может привести к Premature Generalization?

> Следование принципу DRY (Don't Repeat Yourself) может иногда привести к явлению, известному как "premature generalization" (преждевременная обобщенность). Это происходит, когда разработчики создают общие абстракции или универсальные решения еще до того, как они действительно подтвердили, что такие обобщения необходимы.

- Необоснованные предположения: Разработчик может предположить, что в будущем потребуется поддержка различных сценариев использования, и, основываясь на этих предположениях, создаёт сложные общие конструкции. На практике же такие сценарии могут и не появиться.

- Сложность кода: Стремление сделать код универсальным может привести к созданию сложных интерфейсов и зависимостей, что усложняет работу с кодом и его поддержку.

- Усложнение тестирования: Универсальные решения часто сложнее тестировать, поскольку они могут содержать много условий и ветвлений, необходимых для обработки различных сценариев.

- Потеря фокуса: При разработке универсального решения разработчик может отвлечься от основной задачи, пытаясь учесть все возможные варианты, что может затруднить эффективную реализацию текущего функционала.

### Почему при попытке убрать дублирование, мы можем легко ошибиться и выбрать неверный способ рефакторинга?

- Недостаточная информация: На ранних этапах проектирования сложно понять, как изменится код в будущем. С несколькими дублирующимися фрагментами кода разработчики могут не видеть всей картины и не осознают, какие изменения могут потребоваться. Это похоже на статистику, где малый размер выборки может не дать точного представления о более широкой популяции.

- Случайные вариации: Отсутствие дублирования может быть следствием случайных факторов, а не систематического характера. Так же как в статистике несколько случайных результатов могут не отражать реального положения дел, в коде 4-5 повторяющихся фрагментов могут не указывать на наличие общего паттерна.

- Переход от локального к глобальному: Рефакторинг на раннем этапе может привести к созданию универсального решения для конкретных случаев, что делает код более сложным и менее гибким. В статистике, использование незначительных закономерностей для обоснования общих выводов может привести к ошибкам.

- Риск преждевременной обобщенности: Как уже упоминалось, создание общих решений слишком рано может привести к ошибочным предположениям о будущих потребностях. Это похоже на то, как статистики могут делать выводы о популяции, основываясь на недостаточно большом объеме данных.

### Как вы объясните фразу "Duplication is far cheaper than the wrong abstraction."?

> Фраза `"Duplication is far cheaper than the wrong abstraction"` (дублирование гораздо дешевле, чем неправильная абстракция) подчеркивает важность тщательного подхода к абстракции в программировании.

- Дублирование: Дублирование кода, хотя и нежелательно, можно часто исправить или упростить без больших затрат. Если у вас есть несколько повторяющихся фрагментов кода, их можно просто обновить, если появится необходимость, и это проще, чем реализовывать сложные системы абстракций.

- Неправильная абстракция: Создание абстракции с плохой архитектурой или неполным пониманием задачи может привести к более серьезным проблемам. Неправильная абстракция может усложнить программу, сделать ее трудной для понимания и модификации, а также может привести к ошибкам, которые трудно исправить.

- Экономия времени и ресурсов: Дублирование кода, хотя и не идеально, обычно требует меньше времени и усилий, чтобы управлять и поддерживать, чем создание и поддержка неправильных абстракций. Исправление плохой абстракции может потребовать полного пересмотра архитектуры приложения, что существенно увеличивает затраты по времени и ресурсам.

> Таким образом, данная фраза напоминает о том, что лучше оставить дублирование, если это просто и понятно, чем пытаться создать сложную абстракцию, которая не решает задачи и может привести к еще большему количеству проблем. Это же можно сравнить с построением здания: проще исправить небольшие недостатки, чем пытаться построить идеальную структуру с плохой основой.

[Вернуться к началу статьи](#basic)

---

## Separation of concerns

`Separation of concerns` (разделение ответственности) — это принцип проектирования, который предполагает разбиение сложной системы на более мелкие, независимые части, каждая из которых отвечает за свою собственную задачу или функцию. Этот принцип применяется в различных областях, включая программирование, архитектуру, управление проектами и даже везде, где требуется организация информации.

Преимущества :

- Упрощение разработки: Разделяя систему на отдельные компоненты, разработчики могут сосредоточиться на каждой части независимо, что делает процесс разработки более управляемым и менее сложным.

- Улучшение тестируемости: Каждый компонент можно тестировать отдельно, что упрощает выявление и исправление ошибок.

- Повышение читаемости и поддержки: Когда код организован логически, его легче понимать и поддерживать. Это также способствует более легкому обнаружению и устранению проблем.

- Устойчивость к изменениям: Изменения в одной части системы имеют меньший шанс повлиять на другие части, что снижает риск возникновения ошибок.

- Повторное использование кода: Компоненты, отвечающие за отдельные заботы, могут быть повторно использованы в разных контекстах, что повышает эффективность разработки.

> Примеры применения принципа "разделение забот" в программировании включают применение архитектурных паттернов, таких как MVC (Model-View-Controller), где модель, представление и контроллер работают независимо друг от друга.

### Отличия принципа Separation of concerns от Single Responsibility Principle

> Принцип "Separation of concerns" (разделение забот) и принцип "Single Responsibility Principle" (принцип единственной ответственности) имеют много общего, но существуют некоторые ключевые отличия.

1. Объем применения:

- `Separation of concerns` охватывает более широкий спектр, касаясь разбиения системы на независимые, но взаимосвязанные компоненты. Это может включать слои архитектуры, такие как данные, бизнес-логика и интерфейс пользователя.
- `Single Responsibility Principle (SRP)` — это более узкоспецифический принцип, который утверждает, что каждый класс или модуль должен иметь только одну причину для изменения, что подразумевает, что он должен нести только одну ответственность или задачу.

2. Уровень абстракции:

- `Separation of concerns` может применяться на высоком уровне, например, в архитектуре всей системы (например, разделение клиент-сервер, отделение слоя представления от бизнес-логики).
- `Single Responsibility Principle` обычно применяется на уровне отдельных классов или модулей, фокусируясь на том, что каждый класс должен заниматься только одной задачей.

3. Цель:

- `Separation of concerns` стремится создать четкую иерархию и структуру во всей системе, чтобы облегчить управление сложностью и взаимодействие между компонентами.
- `Single Responsibility Principle` стремится уменьшить связанность и повысить модульность кода, что упрощает его поддержку и тестирование.

> В целом, оба принципа направлены на упрощение разработки, улучшение тестируемости и повышение качества кода, но они применяются на разных уровнях и с разными акцентами.

[Вернуться к началу статьи](#basic)

---

## Cross-cutting concerns

`Cross-cutting concerns` (сквозные модули) — это аспекты программы, которые влияют на несколько частей системы и часто пересекаются с основной логикой приложения. Примеры включают логирование, управление транзакциями, безопасность, обработку ошибок и мониторинг. Эти concerns обычно требуют обработки в нескольких модулях или компонентах, что может усложнить поддержку и тестирование системы.

1. Coarse-grained responsibility (грубая ответственность):

- Это означает, что компонент или модуль имеет более широкий и общий набор функций и обязанностей. Например, класс, который обрабатывает как бизнес-логику, так и взаимодействие с базой данных, считается грубым, потому что он берет на себя много задач, связанных с разными аспектами приложения.

- Преимущества: Прежде всего, простота. Грубо распределенные модули могут быть легче в понимании и использовании.

- Недостатки: Сложность в изменениях и тестировании, поскольку изменения в одной области могут повлиять на другие. Такие модули также могут быть сложнее в переиспользовании.

2. Fine-grained responsibility (тонкая ответственность):

- Это относится к более детализированной, узкой и специфичной ответственности компонента или модуля. Например, отдельный класс, который занимается только логированием, или отдельный сервис для работы с конкретной таблицей в базе данных.
- Преимущества: Увеличенная модульность, простота тестирования и переиспользования, легкость в поддержке. Изменения в одном модуле не должны сильно влиять на другие.
- Недостатки: Потенциально может привести к усложнению системы. Слишком мелкие модули могут увеличивать количество кода и связей между ними.

[Вернуться к началу статьи](#basic)

---

## Coroutine

> Корутины `(coroutines)`, или сопрограммы — это блоки кода, которые работают асинхронно, то есть по очереди. В нужный момент исполнение такого блока приостанавливается с сохранением всех его свойств, чтобы запустился другой код. Когда управление возвращается к первому блоку, он продолжает работу. В результате программа выполняет несколько функций одновременно.

Для чего нужны корутины:

- Для создания асинхронных приложений, которые могут выполнять несколько действий одновременно.
- Для гибкой и удобной реализации многозадачности.
- Для большего контроля при переключении между разными задачами. Корутинами управляют разработчик и программа, а не операционная система.
- Для снижения нагрузки на аппаратные ресурсы устройства.

Как работают сопрограммы:

> Сопрограммы — это потоки исполнения кода, которые организуются поверх системных потоков. Поток исполнения кода — это последовательность операций, выполняющихся друг за другом. Она исполняется, пока не наступит момент, который задан в коде или определен разработчиком. Затем может начать выполняться часть другой последовательности операций. В системных потоках содержатся инструкции процессора, на одном его ядре могут по очереди работать разные системные потоки. Корутины работают на более высоком уровне: несколько сопрограмм могут поочередно выполнять свой код на одном системном потоке.

> Для конечного пользователя работа корутин выглядит как несколько действий, которые выполняются параллельно.

> В Computer Science под генераторами понимается data producer, то есть сущность в языке, которая только выдает наружу данные, используя yield. При этом существует более общая концепция, которая называется coroutine или сопрограмма. В отличие от генераторов, она может не только генерировать данные, но так же может и потреблять их (dataconsumer). Самым удивительным в этой истории является то, что генераторы в js, по сути, являются корутинами, а использование их в качестве генераторов – это всего лишь один из возможных вариантов.

[Вернуться к началу статьи](#basic)

---
