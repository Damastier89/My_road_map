# Структуры данных

- [Скалярные типы и строки](#скалярные-типы-и-строки)
- [Массивы](#массивы)
- [Списки, словари (хэш-таблицы), множества](#списки-словари-хэш-таблицы-множества)
- [Кортежи](#кортежи)
- [Стек](#стек)
- [Очередь](#очередь)
- [Множество](#множество)
- [Словарь](#словарь)
- [WeakMap and WeakSet](#weakmap-and-weakset)
- [Изменяемость типов данных](#изменяемость-типов-данных)
- [Сложности операций вставки и поиска](#сложности-операций-вставки-и-поиска)
- [Внутреннее устройство стандартных контейнеров](#внутреннее-устройство-стандартных-контейнеров)
- [Графы](#графы)
- [Деревья](#деревья)
- [Самобалансирующиеся деревья (АВЛ, красно-черное)](#самобалансирующиеся-деревья-авл-красно-черное)
- [Понимание вычислительной сложности О() поиска и вставки данных)](#понимание-вычислительной-сложности-о-поиска-и-вставки-данных)

## `Структуры данных` - это специализированные средства организации и хранения данных на компьютерах таким образом, чтобы мы могли более эффективно выполнять операции с сохраненными данными.

## `Тип данных в веб-программировании` — это классификация данных, которая определяет, какие операции можно выполнять с этими данными и как они будут храниться в памяти.

## `Абстрактный тип данных` в веб-программировании — это концепция, которая описывает тип данных с точки зрения его поведения и операций, которые можно с ним выполнять, независимо от того, как он реализован на самом деле.

В веб-программирование обычно использует следующие основные типы данных:

- `Числовые типы`: целые числа (integer), числа с плавающей запятой (float).
- `Строки`: последовательности символов (например, текстовые данные).
- `Булевы значения`: логические значения, представленные как true или false (истина или ложь).
- `Массивы`: коллекции данных одного типа, которые могут быть доступны по индексу.
- `Объекты`: структуры данных, состоящие из ключей и значений, где ключи — это строки, а значения могут быть разного типа

Примеры абстрактных типов данных включают:

- `Стек`: структура данных, работающая по принципу "последний пришел — первый вышел" (LIFO).
- `Очередь`: структура данных, работающая по принципу "первый пришел — первый вышел" (FIFO).
- `Список`: упорядоченная коллекция элементов, к которой можно обращаться по индексу.

## Скалярные типы и строки

К стандартным скалярным типам относятся данные `целочисленного, вещественного, литерного и булевого типа`.

- `Целочисленный` тип определяет все целые числа в диапазоне от –32768 до +32767. Для их описания служит стандартный идентификатор integer. Байтовый тип аналогичен целочисленному, но охватывает более узкий диапазон значений от 0 до 255.
- `Вещественный` тип данных включает все положительные, отрицательные числа и ноль. Мантисса может содержать до 11 значащих цифр. Описывается стандартным идентификатором real. Если при выполнении арифметических выражений с данными типа real возникает переполнение по верхней границе диапазона, появляется сообщение об ошибке. При выходе значения за нижнюю границу переменной присваивается нулевое значение, и работа продолжается.
- `Булевый` тип данных описывается стандартным идентификатором boolean. Принимает только одно из двух значений: True или False .
- `Литерный` тип данных, идентификатор char. Константы и переменные этого типа могут принимать одно из значений кодовой таблицы ПЭВМ. Значение переменных и констант должно быть заключено в апострофы. Например, 'A', '+', '5', '' , ' ? ', ''''.
- `Скалярные` типы, определённые самим пользователем. К ним относятся перечисляемый и интервальный типы.
  Перечисляемый тип задаётся непосредственно перечислением всех значений, которые может принимать переменная данного типа. Отдельные значения указываются через запятую, а весь список заключается в круглые скобки.
  Интервальный тип позволяет задавать две константы, определяющие границы диапазона значений для данной переменной. Обе константы должны принадлежать одному из типов. Значение первой константы должно быть обязательно меньше второй.
- `Строковый` тип — тип данных, значениями которого является произвольная последовательность символов алфавита. Каждая переменная такого типа может быть представлена фиксированным количеством байтов либо иметь произвольную длину.

[Вернуться к началу статьи](#структуры-данных)

---

## Массивы

`Массив` — упорядоченный набор элементов, каждый из которых хранит одно значение, идентифицируемое с помощью индексов. В простейшем случае массив имеет постоянную длину и хранит единицы данных одного и того же типа, а в качестве индексов выступают целые числа. Так же в массиве могу храниться различные типы данных в любом количестве.
Элементы массива хранятся в памяти рядом, что обеспечивает быстрое чтение. Добавление происходит как в конец(оптимально) так и в начало массива(затратно, пересчитываются все индексы).

[Вернуться к началу статьи](#структуры-данных)

---

## Списки, словари (хэш-таблицы), множества

- `Список` — это абстрактный тип данных, представляющий собой упорядоченный набор значений. Если значение встречается несколько раз, каждое вхождение считается отдельным элементом. Списки используются для хранения коллекций элементов. Списки хранят элементы в том порядке, в котором они были добавлены. Однонаправленный, двунаправленный, кольцевой. В программировании массив и список — это разные структуры данных, хотя они могут иметь схожие функции. Список и массив - это различные структуры данных, которые не привязаны к конкретному языку программирования. В списках элементы хранятся в различных ячейках памяти где угодно. Список требует больших расходов памяти при прочих равных условиях за счет хранения указателей на следующий/предыдущий элементы и особенностей внутренней реализации.

- `Список и связанный список` — это структуры данных, которые используются для хранения коллекций элементов, но они имеют разные характеристики и методы работы.
  Структура:

  - `Список` (например, массив) представляет собой набор элементов, расположенных в последовательной памяти. Каждый элемент имеет индекс, благодаря чему доступ к элементам осуществляется быстро (O(1)).
  - `Связанный список` состоит из элементов (узлов), где каждый узел содержит данные и ссылку на следующий узел в последовательности. Узлы не обязательно находятся в последовательной памяти, что может замедлить доступ (O(n)).

  Динамическое vs. статическое:

  - `Списки` обычно имеют фиксированный размер (в массивах), хотя в некоторых языках (например, в Python с использованием списков) они могут изменяться динамически.
  - `Связанные списки` по своей природе динамичны и могут расширяться и сокращаться по мере добавления или удаления узлов.

  Операции:

  - В `списке` добавление и удаление элементов в середине может требовать перемещения других элементов (O(n)).
  - В `связанном списке` добавление или удаление узла более эффективно (O(1)), если у вас есть указатель на нужный узел.

  Использование памяти:

  - `Списки` могут занимать меньше памяти, так как они не хранят дополнительные ссылки.
  - `Связанные` списки требуют дополнительной памяти для хранения указателей.

  Применение:

  - `Списки` хорошо подходят для случаев, когда необходимо быстро получать доступ по индексу.
  - `Связанные списки` удобны для реализации стеков, очередей и других динамических структур данных.

- `Хэш-таблица` — структура, которая содержит пары ключ/значение. Она использует хэш-функцию для вычисления индекса в массиве из блоков данных, чтобы найти желаемое значение.
- `Хэш-функция` принимает строку символов в качестве вводных данных и выводит числовое значение. Для одного и того же ввода хэш-функция должна возвращать одинаковое число.

Когда вводится пара ключ/значение в хэш-таблицу, ключ проходит через хэш-функцию и превращается в число. В дальнейшем это число используется как фактический ключ, который соответствует определенному значению. Когда вы снова введёте тот же ключ, хэш-функция обработает его и вернет такой же числовой результат. Затем этот результат будет использован для поиска связанного значения. Такой подход сокращает среднее время поиска.

`Множество` хранит значения данных без определенного порядка, не повторяя их. Оно позволяет не только добавлять и удалять элементы:

- Объединение комбинирует все элементы из двух разных множеств, превращая их в одно (без дубликатов).
- Пересечение анализирует два множества и  создает еще одно из тех элементов, которые присутствуют в обоих изначальных множествах.
- Разность выводит список элементов, которые есть в одном множестве, но отсутствуют в другом.
- Подмножество выдает булево значение, которое показывает, включает ли одно множество все элементы другого множества.

[Вернуться к началу статьи](#структуры-данных)

---

## Кортежи

`Кортеж` — упорядоченный набор фиксированной длины. Кортежи неизменяемые структуры данных. Так же как списки они могут состоять из элементов разных типов, перечисленных через запятую. Изменять его элементы нельзя.

[Вернуться к началу статьи](#структуры-данных)

---

## Стек

`Стек` — это структура данных, основанная на принципе "последний пришёл — первый вышел" (LIFO, Last In, First Out). В контексте веб-программирования стек может иметь несколько применений.

Основные операции:

- Стек поддерживает две основные операции:
  - `push`: добавление элемента на верхушку стека.
  - `pop`: удаление и возврат элемента с верхушки стека.
- Элементы могут добавляться и удаляться только с верхушки, что создаёт упорядоченную структуру.

Использование в программировании:

- Стек часто используется для хранения информации о функции и её контексте (например, параметры, локальные переменные) при вызовах функций. Это позволяет возвращаться к предыдущим состояниям после завершения функции.
- При рекурсивных вызовах каждая функция сохраняет своё состояние на стеке, что помогает отслеживать точки возвратов.

Стек технологий в веб-разработке:

- Веб-разработчики также используют термин "стек" для описания набора технологий, используемых для создания веб-приложений. Например, популярные технологические стеки включают MEAN (MongoDB, Express.js, Angular, Node.js) и MERN (MongoDB, Express.js, React, Node.js).
- Каждый из этих стеков содержит разные технологии, которые работают вместе для реализации веб-приложений.

Обработка данных:

- Стек может использоваться для выполнения операций над данными, например, в алгоритмах обхода графов и деревьев (глубина в глубину).

> Принцип `LIFO` (Last In, First Out) — это метод организации данных, при котором последний добавленный элемент является первым, который будет удалён. Другими словами, элементы выходят из структуры данных в обратном порядке их входа. Этот принцип часто используется в различных структурах данных, таких как стек.
>
> Пример:
> Представьте себе стопку тарелок. Если вы добавляете новые тарелки сверху, то, когда придёт время убирать тарелки, вам нужно будет сначала взять ту, которая была положена последней (сверху), а затем — следующую.

> Чтобы получить элемент, находящийся в середине стека, можно использовать несколько подходов. Однако следует помнить, что стеки обычно не поддерживают прямой доступ к элементам, так как работают по принципу LIFO.

В веб-программировании стек используется в различных контекстах.
Стек технологий:

1. Веб-разработчики часто используют определенные комбинации технологий, которые образуют стек. Например:

- MEAN: MongoDB, Express.js, Angular, Node.js.
- MERN: MongoDB, Express.js, React, Node.js.
- LAMP: Linux, Apache, MySQL, PHP.
  Каждый слой в таком стеке отвечает за определенные функции (например, база данных, сервер, клиентская часть).

2. Обработка запросов и маршрутизация:

- Во многих фреймворках (например, Express.js) стеки используются для обработки цепочек промежуточных обработчиков (middleware), которые выполняются последовательно при обработке HTTP-запросов.

3. Состояние приложений:

- В клиентских приложениях, построенных на фреймворках вроде Angular, стек может использоваться для управления состоянием компонентов, особенно при работе с контекстом или библиотеками управления состоянием (например, Redux).

4. История навигации:

- Веб-браузеры используют стек для хранения истории навигации. При переходе на новую страницу URL добавляется в стек, что позволяет пользователю вернуться к предыдущим страницам (кнопка "Назад").

5. Выполнение JavaScript:

- JavaScript использует стек вызовов для управления вызовами функций. Каждый вызов функции добавляет новый контекст выполнения на стек, и когда функция завершается, её контекст удаляется со стека.

6. Обработка событий:

- В JavaScript стек используется для обработки событий, когда функции обратного вызова помещаются в очередь на выполнение, а затем извлекаются и выполняются последовательно.
  Анимации и визуализация:

7. При создании анимаций можно использовать стек для хранения состояний объектов или кадров, которые нужно анимировать.

[Вернуться к началу статьи](#структуры-данных)

---

## Очередь

`Очередь` — это структура данных, которая функционирует по принципу "первым пришёл — первым вышел" (FIFO — First In, First Out). Это значит, что элементы добавляются в конец очереди и извлекаются из её начала.

1. Основные характеристики:

- `Добавление элементов`: Новые элементы добавляются в конец очереди, что обычно называют операцией "enqueue".
- `Извлечение элементов`: Элементы извлекаются из начала очереди, что называется операцией "dequeue".
- `Пустая очередь`: Если очередь пуста, операции извлечения могут вызвать ошибку или вернуть специальное значение.

2.  Использование в веб-программировании:

- `Обработка запросов`: В веб-приложениях очереди могут использоваться для управления запросами от клиентов. Например, сервер может обрабатывать запросы по очереди, чтобы избежать перегрузки.
- `Фоновые задачи`: Очереди пригодны для обработки фоновых задач, таких как отправка электронных писем, выполнение длительных вычислений или обработка данных. Задачи могут помещаться в очередь, и специализированные рабочие процессы могут извлекать и обрабатывать их по мере их поступления.
- `Событийная обработка`: В архитектурах, основанных на событиях, очереди могут использоваться для обработки событий или сообщений, которые генерируются пользователем или системой. Это помогает разделить компоненты системы и улучшить масштабируемость.
- `Кэширование`: Очереди могут помочь управлять данными, которые необходимо кэшировать, позволяя эффективно помещать и извлекать элементы, например, при работе с REST API или другими внешними сервисами.
- `Работа с асинхронностью`: В асинхронных приложениях очереди могут использоваться для упрощения обработки асинхронных операций, позволяя разделить работу на более мелкие, управляемые задачи.

> Чтобы получить предпоследний элемент в очереди, нужно выполнить несколько шагов. Поскольку очередь — это структура данных FIFO (первым пришёл — первым вышел), вам необходимо извлечь элементы из очереди и сохранить необходимые значения.

[Вернуться к началу статьи](#структуры-данных)

---

## Множество

`Множество` (Set) — это коллекция уникальных элементов, которая не сохраняет порядок добавления элементов. Множества широко используются в программировании, включая веб-программирование, для выполнения различных операций с данными.

Основные характеристики множеств:

- `Уникальность элементов`: В множестве не может быть двух одинаковых элементов. Если вы попытаетесь добавить повторный элемент, он не будет добавлен.

- `Неупорядоченность`: Элементы в множестве не имеют фиксированного порядка. Это значит, что вы не можете обращаться к элементам по индексу.

- `Операции`: Множества поддерживают различные операции, такие как объединение, пересечение и разность. Это позволяет эффективно выполнять математические операции над коллекциями данных.

> Элементы множеств (Set) хранятся в памяти по-разному в зависимости от языка программирования и его реализации. Но в общем случае многие языки используют хеш-таблицы или другие структуры данных для обеспечения уникальности и быстрого доступа к элементам.

> В JavaScript стандартное множество Set на самом деле реализовано с использованием хеш-таблицы под капотом. Это позволяет Set обеспечивать время добавления и поиска в среднем O(1) (константное время).

[Вернуться к началу статьи](#структуры-данных)

---

## Словарь

`Словарь`, также известный как `Map`, в веб-программировании — это структура данных, которая позволяет хранить пары ключ-значение. Это позволяет эффективно организовывать данные и выполнять операции по доступу, добавлению и удалению элементов с использованием уникальных ключей.

Основные характеристики словаря (Map):

- `Ключи и значения`: Каждая пара в Map состоит из ключа, который уникален, и соответствующего ему значения. Это позволяет легко получать значение по ключу.

- `Типы ключей`: В Map ключи могут быть любого типа: строками, числами, объектами и даже функциями. Это отличие от обычных объектов JavaScript, где ключами могут быть только строки или символы.

- `Порядок элементов`: В Map сохраняется порядок вставки элементов, поэтому при переборе элементов вы получите их в том порядке, в котором они были добавлены.

- Методы: Map предоставляет различные методы для работы с данными:

  - set(key, value): добавляет или обновляет элемент с заданным ключом.
  - get(key): возвращает значение по заданному ключу или undefined, если такой ключ отсутствует.
  - has(key): проверяет, существует ли элемент с указанным ключом.
  - delete(key): удаляет элемент с заданным ключом.
  - clear(): удаляет все элементы из Map.
  - size: возвращает количество пар ключ-значение в Map.

- `Эффективность`: Большинство операций (добавление, удаление, поиск) выполняются за константное время O(1), что делает Map высокоэффективным для работы с ассоциативными массивами.

[Вернуться к началу статьи](#структуры-данных)

---

## WeakMap and WeakSet

`WeakMap и WeakSet` — это специальные структуры данных в JavaScript, которые работают аналогично Map и Set, но имеют свои уникальные особенности, связанные с управлением памятью.

WeakMap

- Ключи: В WeakMap ключами могут быть только объекты. Примитивные типы данных не могут быть использованы в качестве ключей.
- Слабые ссылки: WeakMap сохраняет "слабые" ссылки на ключи, что позволяет сборщику мусора освобождать память, если на объект-ключ больше нет никаких ссылок. Это помогает избежать утечек памяти.

Методы:

- set(key, value): добавляет или обновляет элемент с заданным ключом.
- get(key): возвращает значение, ассоциированное с ключом, или undefined, если ключ не найден.
- has(key): проверяет, существует ли элемент с заданным ключом.
- delete(key): удаляет элемент с заданным ключом.

WeakSet

- Элементы: В WeakSet могут храниться только объекты. Примитивные значения не могут быть добавлены.
- Слабые ссылки: Подобно WeakMap, WeakSet хранит слабые ссылки на объекты, что позволяет их сборщику мусора удалять, если на объект больше нет ссылок.

Методы:

- add(value): добавляет объект в коллекцию.
- has(value): проверяет, есть ли объект в коллекции.
- delete(value): удаляет объект из коллекции.

[Вернуться к началу статьи](#структуры-данных)

---

## Изменяемость типов данных

Объекты, чье значение может измениться, называются изменяемыми; объекты, значение которых неизменяемо после их создания, называются неизменяемыми.
Изменчивость объекта определяется его типом; например, числа, строки и кортежи неизменны, а словари и списки изменчивы.

[Вернуться к началу статьи](#структуры-данных)

---

## Сложности операций вставки и поиска

- В случае с массивом (добавление в начало) необходимо пересчитать все индексы.
- ???

[Вернуться к началу статьи](#структуры-данных)

---

## Внутреннее устройство стандартных контейнеров

`Список` – ещё один последовательный контейнер:

> ![изображение стандарного контейнера](./images/list.png 'изображение стандарного контейнера')

Каждый элемент хранится в своей области памяти независимо от других элементов.
Последовательный доступ к элементам списка:

- доступ по индексу отсутствует: чтобы получить доступ к 4-му элементу, надо последовательно пройти первые 3 элемента
- «медленный» доступ к произвольному элементу, «быстрый» к следующему/предыдущему
- функция size() «перелистывает» весь список
- Легко осуществляется добавление и удаление элементов:
- операция не затрагивает никакие другие элементы, кроме тех с которыми она производится
- меняются только ссылки на следующий и предыдущий элементы
- при добавлении выделяется память для элемента контейнера, при удалении же освобождается

Множество специализированных функций для «перемещения» элементов.
Словарь — тип данных, представляющий собой коллекцию пар "ключ-значение". В рамках одного словаря ключи не повторяются. Словарь не запоминает порядок добавления элементов и вместо этого сохраняет элементы так, чтобы операции над содержимым словаря были максимально эффективны.

[Вернуться к началу статьи](#структуры-данных)

---

## Графы

- С греческого граф — «пишу», «описываю». Граф — это множество точек (вершин, узлов), которые соединяются множеством линий (рёбер, дуг). Теория графов (то есть систем линий, соединяющих заданные точки).

[Вернуться к началу статьи](#структуры-данных)

---

## Деревья

- Основные характеристики:

  - `Узлы`: Каждый узел в двоичном дереве содержит данные и ссылки на левого и правого ребенка.
  - `Корень`: Верхний узел дерева называется корнем.
  - `Листья`: Узлы, не имеющие дочерних узлов (т.е. не имеющие детей), называются листьями.
  - `Глубина и высота`: Глубина — это максимальное количество от корня до листа. Высота дерева обычно равна глубине его листьев.

- Это связный ациклический граф. Связность означает наличие маршрута между любой парой вершин, ацикличность — отсутствие циклов. Отсюда, в частности, следует, что число рёбер в дереве на единицу меньше числа вершин, а между любыми парами вершин имеется один и только один путь.

- Структура HTML-документа представляется в виде дерева узлов, где каждый тег HTML является узлом. Это дерево называется "дерево узлов" (DOM — Document Object Model). Браузеры используют DOM для отображения и манипуляции содержимым веб-страницы.

- В системах управления версиями (например, Git) используются деревья для представления состояний файлов и директорий.

- Глубина дерева — это мера, которая описывает, насколько "глубоко" расположены узлы в структуре дерева. Она определяется как максимальное количество узлов, по которым необходимо пройти от корневого узла дерева до самого глубокого узла (листа).

- Двоичные деревья — это структуры данных, в которых каждый узел имеет не более двух дочерних узлов, обычно называемых "левым" и "правым" ребенком. Эти деревья могут использоваться для представления и хранения упорядоченной информации, благодаря чему они находят широкий спектр применения в программировании, включая веб-программирование.

  - Типы двоичных деревьев:

    - `Бинарные поисковые деревья` (BST): В них для любого узла все значения в левом поддереве меньше, чем значение самого узла, а все значения в правом поддереве больше. Это делает их особенно полезными для быстрой сортировки и поиска.
    - `Сбалансированные двоичные деревья`: Например, AVL-деревья и красно-черные деревья, которые поддерживают сбалансированную высоту для улучшения производительности.
    - `Двоичные кучи`: Они структурированы так, чтобы наивысший (или наименьший) элемент всегда находился в корне, что эффективно для реализации алгоритмов сортировки и работы с приоритетами.

  - Использование в веб-программировании:
    - `Поиск и сортировка`: Двоичные деревья, особенно бинарные поисковые деревья, используются для реализации эффективных алгоритмов поиска и сортировки данных.
    - `Хранение и управление данными`: Они могут использоваться для хранения и управления данными, такими как маршруты в веб-приложениях, иерархические структуры (например, меню навигации) и для реализации различных кэш-стратегий.
    - `Работа с DOM`: Веб-документы в браузерах представлены в виде дерева (DOM), и многие операции, включая добавление, удаление и изменение элементов, могут быть реализованы с использованием концепций, схожих с двоичными деревьями.
    - `Алгоритмы и структуры данных`: Разработчики могут использовать двоичные деревья, чтобы реализовать различные алгоритмы, такие как обход дерева, и применять их в веб-приложениях для улучшения производительности и организации кода.

[Вернуться к началу статьи](#структуры-данных)

---

## Самобалансирующиеся деревья (АВЛ, красно-черное)

- АВЛ-дерево - сбалансированное по высоте двоичное дерево поиска: для каждой его вершины высота её двух поддеревьев различается не более чем на 1. То есть, по сути - идеально сбалансированное дерево.
  Для поддержания баланса, если при новой вставке высота поддеревьев различается больше, чем на 1, происходит балансировка (один из 4-х видов - малая левая, большая левая, малая правая, большая правая). Вид балансировки определяется ситуацией (в какую позицию относительно соседей вставлено).

- Красно-черное дерево - еще один вид самобалансирующихся деревьев, только дерево не идеально, а "примерно" сбалансированно. В каждую вершину добавляется еще одно поле - бит, отвечающий цвету (красный или черный). С помощью этого поддерживаются следующие свойства:

Разница. Так как в идеально сбалансированном дереве много ресурсов тратится на поддержание сбалансированности, рекомендуется использовать его в ситуации, когда вставка/удаление происходит существенно реже считывания. Красно-черные деревья, наоборот, тратят меньше ресурсов на поддержание сбалансированности (хотя здесь тоже есть перебалансировка), и их лучше использовать, когда вставка и чтение проиходят примерно с одинаковой частотой. Именно на основе красно-черных деревьев основываются большинство реализаций set и map из STL.

[Вернуться к началу статьи](#структуры-данных)

---

## Понимание вычислительной сложности О() поиска и вставки данных

O-большое — это количество операций. Сложность алгоритмов обычно оценивают по времени выполнения или по используемой памяти. Формально O(f(n)) означает, что время работы алгоритма растёт в зависимости от объёма входных данных не быстрее, чем некоторая константа, умноженная на f(n). O(n) — линейная сложность. O(log n) — логарифмическая сложность. O(n2) — квадратичная сложность.

[Вернуться к началу статьи](#структуры-данных)
