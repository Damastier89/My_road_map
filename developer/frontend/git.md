# GIT

`Git` — система управления версиями с распределенной архитектурой и абсолютный лидер по популярности среди современных систем управления версиями. 
> Это развитый проект с активной поддержкой и открытым исходным кодом. 
  Система Git была изначально разработана в 2005 году Линусом Торвальдсом — создателем ядра операционной системы Linux. 
  Git применяется для управления версиями в рамках колоссального количества проектов по разработке ПО, как коммерческих, так и с открытым исходным кодом. 
  Система используется множеством профессиональных разработчиков программного обеспечения. 
  Она превосходно работает под управлением различных операционных систем и может применяться со множеством интегрированных сред разработки (IDE).

### Working directory, Staging area и Repository
> Эти термины касаются систем контроля версий, таких как Git, и используются в процессе управления изменениями в проекте.

> Рабочий каталог `Working directory` - это текущий рабочий каталог проекта, в котором вы вносите изменения в файлы проекта.

> Область подготовки `Staging area`, также известная как индекс, является промежуточной областью, где вы определяете, какие изменения ваших файлов должны быть внесены в следующую ревизию проекта.

> Хранилище `Repository` - это место, где сохраняются все версии файлов вашего проекта, включая их историю изменений. Здесь вы можете отслеживать изменения в вашем проекте, возвращаться к предыдущим версиям, сравнивать изменения между версиями и т.д.

Таким образом, рабочий каталог - это ваш рабочий инструмент, предназначенный для внесения изменений в проект, область подготовки - промежуточный этап, где вы определяете, какие изменения следует включить в следующую ревизию проекта, а хранилище - это место, где они действительно сохраняются и могут быть отслежены в будущем

### `.gitignore`
> Файл `.gitignore` содержит список шаблонов (пути и имена файлов и папок), которые Git должен игнорировать при работе с репозиторием. Если вы добавите файлы в этот файл, то при выполнении команды git add или git commit они будут проигнорированы, а Git не будет их коммитить или отображать в статусе изменений.

### `git config`
> Команда git config используется для установки и получения параметров конфигурации Git, которые применяются на уровне глобальной конфигурации пользователя, репозитория и текущей сессии Git.

В частности, с помощью команды git config можно выполнять следующие задачи:

- установить и получить пользовательское имя и электронную почту, используемые для атрибуции коммитов;
- изменить поведение Git, такое как дефолтное количество строк контекста в результатах команды git diff или настройки форматирования логов;
- добавлять, изменять и удалять алиасы команд Git для удобства использования.

Три уровня конфигурации в Git:

- Глобальный уровень: устанавливает общие настройки для текущего пользователя, которые будут применяться ко всем репозиториям, с которыми пользователь работает на данной машине. Конфигурация на этом уровне хранится по умолчанию в файле `~/.gitconfig`.
- Уровень репозитория: определяет настройки конкретного репозитория Git. Эта конфигурация хранится в файле `.git/config` в корневой папке репозитория и применяется только к данному репозиторию.
- Уровень командной строки: определяет временные изменения в конфигурации Git, применяемые только для текущего запуска команды Git. Он может использоваться, например, для перезаписи настроек Git в процессе автоматизации или для переопределения частной настройки репозитория для одной команды.

### Команды fetch и merge
> Команды `fetch` и `merge` - это две основные команды Git, которые используются для обновления локальной копии репозитория до последней версии из удаленного репозитория.

- Команда `fetch` позволяет получить все изменения, которые были добавлены в удаленный репозиторий с момента последней синхронизации, и добавить их в ваш локальный репозиторий, но без апдейта локальных веток, что значит, что вы не будете перескакивать на новую версию кода. То есть после команды fetch, если вы сделаете git status, то увидите, что ваша локальная версия все еще та же самая, что и до команды fetch.

- Команда `merge` позволяет объединить изменения из удаленного репозитория с вашим локальным репозиторием, что приведет к изменению локальных веток. То есть команда merge совмещает исходную ветку, какой-нибудь другой, с вашей текущей веткой, с тем чтобы ваши локальные изменения сбрасывались в новую версию и ваш репозиторий становился синхронизированным с удаленным репозиторием. В результате могут появляться конфликты слияния, которые нужно разрешать.

> Обычно эти команды используются в паре: сначала fetch, чтобы получить изменения из удаленного репозитория, и затем merge, чтобы объединить их с вашим локальным репозиторием. Это позволяет вам получать и использовать последние изменения, внесенные другими участниками проекта.

### fast-forward merge

> `Fast-forward` merge это способ объединения веток в Git, который по умолчанию используется при наличии линейной истории изменений (то есть, когда ветка, на которую выполняется слияние, находится непосредственно впереди текущей в структуре репозитория). При выполнении fast-forward merge Git просто перемещает указатель текущей ветки вперед, к той же самой точке, в которой находится ветка, с которой выполняется слияние, что позволяет сохранить линейную историю изменений без создания новых коммитов.

- Флаг `--squash` используется при слиянии веток (merge), чтобы объединить все коммиты из ветки в один коммит, который затем можно смержить в другую ветку. Это полезно, когда вы хотите сохранить линейную историю коммитов. В частности, --squash избегает создания полного слияния коммитов из ветки, которую вы вливаете.

- Флаг `--no-ff` используется для отключения fast-forward в слиянии. Он заставляет Git создавать новый коммит-слияние, даже если он мог бы выполнить fast-forward. Это полезно, когда вы хотите учитывать историю всех слияний. Кроме того, это сделать необходимым компанию за соблюдение той или иной схемы слияний или для того, чтобы оставить запись в истории коммитов, что две ветки были объединены, даже если возможно было выполнение быстрого forward автоматически.

> В целом, использование этих флагов дает более полный и точный контроль над процессом слияния и историей коммитов в вашем репозитории.

### Pull Request (PR) или Merge Request (MR)

> Pull Request (PR) или Merge Request (MR) - это механизм, используемый в системах контроля версий, таких как Git или GitHub, для обмена изменениями между разными ветками репозитория или между разными репозиториями.

Когда разработчик хочет внести изменения в проект, проходит следующие стадии:

1. Создание новой ветки – ветка создается на основе основной ветки репозитория, например, master, в которой разработчик будет менять и добавлять файлы.
2. Внесение изменений - разработчик вносит требуемые изменения в файлы в рамках своей ветки.
3. Создание `Pull Request/Merge Request` - после завершения работы, разработчик создает запрос на слияние изменений с основной веткой. В PR/MR указывается: какие изменения внесены, какие и зачем файлы изменились, к кому этот Pull Request адресован, а также комментарии и подробное описание работы.
4. `Code review` - После создания `PR/MR` код предоставляется на рассмотрение других разработчиков, которые могут оставить комментарии и советы по улучшению кода.
5. Мержинг - Если все комментарии учтены и изменения одобрены другими разработчиками, менеджер проекта или администратор сливает изменения в основную ветку репозитория.

> `Pull Request/Merge Request` являются важной частью современной методологии разработки программных продуктов, так как они позволяют контролировать процесс слияния изменений, уменьшая ошибки и конфликты, и облегчая сборку кода и релизы.

### Команды для управления git
`git log` - Просмотр истории коммитов с подробной информацией.

`git rebase` — Способ перенести изменения из одной ветки в другую. В отличие от `merge`, перемещение перезаписывает историю. В процессе устраняется нежелательная история.

`fast-forward` - Другими словами, если коммит сливается с тем, до которого можно добраться двигаясь по истории прямо, Git упрощает слияние просто перенося указатель ветки вперед, так как нет расхождений в изменениях.

`git cherry-pick` - Команда git cherry-pick используется для перенесения отдельных коммитов из одного места репозитория в другое, обычно между ветками разработки и обслуживания. Этот механизм отличается от привычных команд git merge и git rebase, которые переносят коммиты целыми цепочками

`git bisect` - На каждом этапе он пытается сократить количество потенциально плохих ревизий вдвое.

`git hooks` — Скрипты оболочки, которые запускаются автоматически до или после того, как Git выполняет важную команду, такую как Commit или Push.

`git clone`  — Скачать из удаленно репозитория проект.

`git pull` — Обновить проект, после внесения изменения его другим разработчиком.

`git checkout -b «branchName»` - копирует и переносит всё в новую ветку.

`git checkout -b recevered «branchName»` - восстановить удаленную ветку(локально)

`git branch -d(-D) «branchName»` - удалить ветку.

`git branch -M «branchName»` - изменить название ветки.

`git commit --amend --no-edit` - оставить то же имя коммита, но перезаписать содержимое.

`git commit --amend -m«Name»` - изменить имя последнего коммита.

`git merge master «branchName»` - перенести изменения из одной ветки в другую.
 > Плюсы: сохраняет полную историю и хронологический порядок, поддерживает контекст ветки.
 
 > Минусы: история коммитов может быть заполнена (загрязнена) множеством коммитов, отладка с использованием git bisect может стать сложнее.

`git reset HEAD~` - отменить последний коммит, но сохранить изменения.

`git reset` --hard HEAD~(хеш ветки) - удалить последний коммит и откатить изменения.

`git reset` --hard master@{"10 minutes ago"} - cброс к определенному моменту времени.

`git diff` - просмотр не индексированных изменений.

`git reflog` — посмотреть хеши и логи.

`git stash` – спрятать изменения.

`git stash pop` – достать изменения

`git stash --keep-index` - в stash уйдут все изменения кроме тех что уже добавлены в индекс(подготовлены для комита).

### Git Style
`Name_project/fix/task_name` – Именование ветки для fix-bag.

`Name_project/feature/task_name` – Именование для ветки с новым функционалом.

`Name_project/refactor/task_name` – Именование для ветки для правки кода.

`git commit -m"fix(‘component name’): 'task name' ‘текс коммита’."` --no-verify – Так выглядит коммит если фиксился баг. (--no-verify – используется опционально, если husky не пропустил)

`git commit -m"feat(‘component name’): 'task name' ‘текс коммита’."` – Так выглядит коммит если добавили новый функционал.

`git commit -m"refactor(‘component name’): 'task name' ‘текс коммита’."` – Так выглядит коммит если привили код.

### Git problem
`git config --system core.longpaths true` – если возникла проблема «Filename too long»
