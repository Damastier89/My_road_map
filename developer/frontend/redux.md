# REDUX

- [Store](#store)
- [Action and reducer](#action-and-reducer)
- [Изменения в state](#change-state)
- [Зачем нужен dispatch?](#dispatch)
- [Asynchronous action](#asynchronous-action)
- [Locale state](#store-locale-state)
- [Save state](#save-state)
- [Saving data in store](#saving-data-in-store)

> Стейт-менеджер (или менеджер состояния) — это инструмент или паттерн программирования, используемый в разработке программного обеспечения для управления состоянием приложения. Он помогает разработчикам эффективно управлять данными и их изменениями в приложении.

> Стейт-менеджер необходим для улучшения управления состоянием в сложных приложениях, где данные могут меняться в разных частях приложения и требуют синхронизации. Он облегчает отслеживание состояния приложения, управление обновлениями интерфейса и реакцию на взаимодействия пользователя.

> Веб-приложения, мобильные приложения и другие типы приложений могут использовать стейт-менеджеры для более эффективного управления данными и состоянием интерфейса. Популярные стейт-менеджеры включают Redux, MobX, Vuex (для Vue.js), и другие.

## Store

> `Store (хранлище)` — это центральное хранилище данных в структуре приложения, где хранится состояние приложения и данные, необходимые для его функционирования. Store часто используется в сочетании со стейт-менеджерами, такими как Redux, для управления состоянием и взаимодействием с данными.

В Store обычно содержится:

- Состояние приложения: это данные, определяющие текущее состояние приложения. Например, веб-странице или мобильном приложении могут содержаться данные о пользователе, список задач, настройки приложения и т.д.
- Редукторы (reducers): функции, определяющие, как изменения состояния обрабатываются в приложении. Редукторы принимают текущее состояние и действие (action) и возвращают новое состояние.
- Middleware (промежуточное программное обеспечение): это дополнительные функции, которые позволяют выполнять дополнительные действия при обновлении состояния, такие как логирование, асинхронные операции и другие.

> Store обеспечивает единую точку доступа к данным приложения, что упрощает управление состоянием, обновление интерфейса и отладку. Путем изменения состояния в Store приложение автоматически обновляется на основе новых данных

[Вернуться к началу статьи](#redux)

---

## Action and reducer

> `Action (действие)` в контексте управления состоянием приложения (например, в Redux) представляет собой объект, который описывает событие, произошедшее в приложении. Действия обычно имеют тип (type) и дополнительные данные (payload), которые могут передаваться в reducers для обновления состояния приложения. Действия запускают процесс обновления состояния и обеспечивают структурированный способ взаимодействия между различными частями архитектуры приложения.

- Чтобы создать action-creator (создатель действий), вы можете определить функцию, которая будет возвращать объекты действий.

```typescript
import { createAction, props } from '@ngrx/store'
export interface IMessage {
	message: string
}

// action - это сообщения или действия, которые происходят в приложением
export const increaseCounter = createAction(AppActionType.APP_INC)

export const sendMessage = createAction(
	AppActionType.APP_SEND,
	props<IMessage>() // В props храниться информация, которая будет передаваться в action
)
```

> `Reducer (редюсер)` - это функция, которая принимает текущее состояние и действие (action), и возвращает новое состояние. Редукторы являются чистыми функциями, которые не должны изменять переданные аргументы, а должны возвращать новый объект состояния на основе старого состояния и примененного действия.

- Reducer отвечают за обновление состояния приложения в ответ на действия, которые происходят в приложении. Они представляют собой ключевую часть управления состоянием и играют роль в определении, каким образом данные будут изменяться и взаимодействовать между собой в приложении.

```typescript
// Начальное состояние
const initialState: State = {
	count: 0,
}

// Reducer - это функция, которая меняет состояние.
// Когда именно нужно менять состояние Reducer узнает от Action

export const appReducer = createReducer(
	initialState,
	// Передаем в on() первым аргументом action для выполнения, этот action далее будет передан в компоненте в функцию dispatch(),
	// для того что бы оповестить store, что произошли какие-то изменения по этому action,
	// а далее уже reducer выполнит указанные в нем инструкции и как-то изменит состояние.
	// Вторым параметром передаем функцию, которая будет менять состояние initialState.
	on(increaseCounter, state => ({
		...state,
		count: state.count + 1,
	})),
	on(decreaseCounter, state => ({
		...state,
		count: state.count - 1,
	})),
	on(sendMessage, (state, action) => ({
		...state,
		message: action.message,
	}))
)
```

[Вернуться к началу статьи](#redux)

---

## Change state

### Почему любые изменения в state должны быть иммутабельны?

- `Предсказуемость`: При использовании иммутабельных операций свойство состояния приложения не изменяется напрямую. Это делает код более предсказуемым и упрощает отслеживание того, как и когда происходят изменения состояния.

- `Отслеживаемость`: Иммутабельность упрощает обнаружение изменений в состоянии, так как каждый раз при изменении состояния создается новый объект или копия, что позволяет легко сравнивать текущее и предыдущее состояние.

- `Избежание нежелательных побочных эффектов`: Изменение состояния напрямую может привести к нежелательным побочным эффектам, таким как непредсказуемое поведение компонентов или ошибки в работе приложения. При использовании иммутабельности такие проблемы могут быть предотвращены.

- `Оптимизация производительности`: Библиотеки управления состоянием, такие как Redux, могут оптимизировать процессы обновления состояния, используя проверку ссылки на объекты, что упрощает определение необходимости перерисовки компонентов.

- `Параллельное выполнение`: Иммутабельность облегчает параллельное выполнение кода, так как неизменяемость данных обеспечивает более простое управление состоянием и избегает состояний гонки.

> В целом, использование иммутабельности для изменения состояния помогает создавать более надежные, предсказуемые и легко поддерживаемые приложения

[Вернуться к началу статьи](#redux)

---

## Dispatch

> `Dispatch` используется в контексте управления состоянием в приложениях, особенно там, где применяется концепция управления состоянием через actions и reducers, такая как в Redux.

- `Инициирование действий (actions)`: Dispatch используется для запуска действий (actions), которые определяют, какое изменение должно произойти со стейтом (состоянием) приложения.

- `Централизация управления состоянием`: Dispatch позволяет централизованно управлять всеми действиями и изменениями состояния в приложении. Это способствует соблюдению принципов единого источника и однонаправленного потока данных.

- `Асинхронное изменение состояния` : С помощью dispatch можно выполнять асинхронные операции, такие как вызовы API, а затем обновлять состояние приложения с учетом результата этих операций.

- `Использование middleware`: Dispatch позволяет использовать middleware для обработки действий на разных этапах, что делает его мощным инструментом для применения логики, валидации данных, логгирования и других аспектов управления состоянием.

- `Разделение бизнес-логики и представления`: Dispatch помогает разделить бизнес-логику от компонентов представления, позволяя компонентам генерировать действия без прямого доступа к состоянию.

[Вернуться к началу статьи](#redux)

---

## Asynchronous action

> Для задиспатчивания асинхронного действия (asynchronous action) в приложении, часто используется средство, такое как middleware, например, в Redux можно использовать Redux Thunk.

> Вот пример того, как можно задиспатчить асинхронный action с использованием Redux Thunk:

```npm
npm install redux-thunk
```

[Вернуться к началу статьи](#redux)

---

## Store locale state

> В React рекомендуется избегать хранения локального состояния компонента в глобальном состоянии (state), потому что это может привести к сложностям в управлении состоянием и привести к неявным ошибкам в приложении. Вот несколько причин, почему локальное состояние компонента не должно храниться в глобальном состоянии:

- Лишняя сложность: Если каждый компонент будет хранить свое локальное состояние в глобальном состоянии, это может привести к увеличению сложности кода и усложнения отслеживания, где и как изменяется состояние.

- Излишняя рендеризация: Использование глобального состояния для локального состояния может привести к излишней рендеризации компонентов, так как любое изменение глобального состояния вызовет перерендеринг всех компонентов, использующих это состояние.

- Проблемы синхронизации: Если различные компоненты используют одно и то же локальное состояние из глобального состояния, может быть сложно гарантировать согласованность данных и их обновление.

- Производительность: Хранение лишнего состояния в глобальном хранилище может отрицательно сказаться на производительности приложения из-за избыточных обновлений.

> Вместо того, чтобы хранить локальное состояние компонента в глобальном состоянии, рекомендуется использовать локальный state в самом компоненте с помощью useState, useReducer или других средств управления состоянием внутри компонента. Такой подход обеспечивает чистоту принципа однонаправленного потока данных и упрощает управление состоянием в приложении.

[Вернуться к началу статьи](#redux)

---

## Save state

> В Angular или React состояние (state) компонентов не сохраняется автоматически при перезагрузке страницы. При обновлении страницы Angular приложение перезапускается снова, и все состояния компонентов сбрасываются до начальных значений.

> Для сохранения состояния между перезагрузками страницы в Angular, вы также можете использовать методы, такие как Local Storage или Cookies. Можно сохранять данные в Local Storage при выходе из приложения и загружать их обратно при повторном входе.

> Таким образом, сохранение состояния после перезагрузки страницы — это дополнительная задача, за которую отвечает разработчик. Angular не предоставляет встроенного механизма для автоматического сохранения состояния между перезагрузками страницы.

[Вернуться к началу статьи](#redux)

---

## Saving data in store

> Хранение данных аутентификации/авторизации в состоянии (state) приложения во фронтенде может быть рискованным и не безопасным решением. Вот почему:

- `Безопасность`: Хранение конфиденциальных данных, таких как токены доступа или данные аутентификации, в клиентском состоянии (например, в переменных JavaScript или в localStorage) может сделать их уязвимыми для атак, таких как XSS (межсайтовый скриптинг). Злоумышленники могут попытаться получить доступ к этим данным и использовать их для несанкционированного доступа к ресурсам.

- `Управляемость и персистентность`: Состояние фронтенда может быть утеряно при перезагрузке страницы или при переключении между вкладками, что может привести к нестабильной работы приложения и потере данных аутентификации/авторизации.

- `Надежность`: Хранение данных аутентификации/авторизации на стороне сервера обычно более надежное и безопасное, поскольку сервер имеет больше контроля над данными и их обработкой.

> Рекомендуется хранить данные аутентификации/авторизации на сервере и передавать только необходимую информацию в зашифрованном виде между клиентом и сервером через защищенные протоколы. В клиентской части приложения можно хранить только токен доступа с ограниченным временем жизни для выполнения запросов к API.

[Вернуться к началу статьи](#redux)

---
