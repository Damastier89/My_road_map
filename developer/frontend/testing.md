# Testing

- [Unit-test](#unit-test)
- [Integration testing](#integration-testing)
- [Чем юнит-тесты отличаются от интеграционных тестов?](#unit-test-and-integration-testing)
- [TDD](#tdd)
- [Regression bugs](#regression-bugs)
- [Side effects](#side-effects)
- [SPY](#spy)
- [Что такое граничные условия?](#boundary-conditions)
- [Что такое heisenbug? Какие есть способы их дебаггинга?](#heisenbug)
- [Что такое fixture?](#fixture)
- [Что такое покрытие кода тестами?](#code-coverage)
- [Закономерности при отказе тестов](#patterns)
- [Как тесты помогают в проектировании?](#tests-help-in-designing)
- [Библиотеки для создания тестов и их запуска](#libraries-for-creating-and-running-tests)
- [Ручное тестирование](#manual-testing)
- [Пирамида тестирования](#testing-pyramid)
- [End-to-end (E2E) тесты](#end-to-end)
- [Test Double and Fake](#test-double-and-fake)
- [Behavior and state verification](#behavior-and-state-verification)
- [Solitary и Sociable тесты](#solitary-and-sociable-tests)

## Unit-test

> Unit-тестирование - это процесс проверки корректности работы отдельных, изолированных единиц кода, таких как функций, классов или методов.

> Целью unit-тестирования является измерение качества и надежности кода, а также уменьшение количества ошибок, которые могут возникнуть при работе программы в процессе разработки. Тестирование каждой единицы кода производится отдельно, без взаимодействия с другими модулями или зависимостями.

> Как правило, unit-тесты создаются в виде специальных функций, которые проверяют поведение отдельных модулей.
> Тесты могут включать в себя определенные значения, которые ожидаются от функции при определенных условиях, например, входные параметры. Проверка выполняется с помощью assert-операторов, которые определяют соответствие между ожидаемыми значениями и фактическими результатами.

```javascript
function sum(a, b) {
	return a + b
}

function test() {
	assert(sum(1, 2) === 3)
	assert(sum(0, 0) === 0)
	assert(sum(-1, 1) === 0)
}

test()
```

### Группирование отдельных тестов внутри unit-тестов имеет несколько преимуществ:

- `Читаемость тестов`: Группирование повышает читаемость тестов, поскольку сгруппированные тесты могут описывать схожие функции.
- `Поддерживаемость тестов`: Группирование тестов облегчает поддержку тестов в долгосрочной перспективе. Тестирование сгруппированных тестов легче поддается изменениям и разработчики могут быстрее обнаружить, если определенные изменения неправильно повлияли на группу тестов.
- `Включение и исключение тестов из запуска`: Группирование тестов позволяет включать или исключать определенные группы тестов.
- `Повторное использование тестов`: Группирование тестов облегчает повторное использование кусков кода, который группируется и может использоваться в других тестовых наборах.
- `Масштабируемость`: Группирование тестов облегчает масштабирование тестов и позволяет эффективно добавлять новые тесты при необходимости.

В целом, группирование отдельных тестов внутри unit-тестов помогает упростить и упорядочить тестирование, повышает его эффективность и облегчает его поддержку.

[Вернуться к началу статьи](#testing)

---

## Integration testing

> Интеграционное тестирование - это процесс проверки успешной работы взаимодействия между различными компонентами системы, такими как базы данных, серверные API, пользовательские интерфейсы и другие. Целью интеграционного тестирования является проверка корректности и правильности работы системы в целом

> При интеграционном тестировании проверяется, как работает взаимодействие между компонентами, запущенными вместе в реальном окружении. Основным принципом интеграционного тестирования является проверка “черного ящика”, когда тестируется только выходной результат системы при заданных входных параметрах и условиях.

> Тесты могут быть выполнены как автоматически, так и вручную. Автоматические тесты могут включать в себя сценарии использования, которые проверяют работу с конечным пользователем и проверку взаимодействия компонентов системы, начиная от самых простых до наиболее сложных. Также могут проводиться эмуляции и симуляции системного окружения для проверки взаимодействия между компонентами.

[Вернуться к началу статьи](#testing)

---

## Unit test and Integration testing

> Юнит-тесты и интеграционные тесты являются двумя основными типами тестирования в разработке программного обеспечения.

Юнит-тесты:

- Цель: Проверить отдельные части кода (обычно функции, методы, классы) изолированно от других компонентов системы.
- Особенности: Обычно используют заглушки (mocks) или стабы для имитации зависимостей.
- Преимущества: Быстрота выполнения, можно легко автоматизировать, помогают обнаруживать и исправлять ошибки в ранней стадии разработки.
- Недостатки: Могут не обнаружить проблемы интеграции между компонентами.

Интеграционные тесты:

- Цель: Проверить, как отдельные компоненты взаимодействуют между собой и правильно ли работает система в целом.
- Особенности: Тестируют сценарии использования, интеграцию между различными частями программы или между различными сервисами.
- Преимущества: Обнаруживают проблемы взаимодействия между компонентами, проверяют, что все работает вместе правильно.
- Недостатки: Сложнее настроить и писать, требуют больше времени для запуска, могут быть менее надежными из-за многочисленных зависимостей.

Интеграционные тесты сложнее написать и поддерживать по нескольким причинам:

- Зависимости между компонентами: Интеграционные тесты требуют наличия всех зависимостей и необходимой среды выполнения, что усложняет их настройку.
- Сложность сценариев: Настройка сценариев для тестирования интеграции между различными компонентами может быть сложной и требует тщательного планирования.
- Скорость выполнения: Интеграционные тесты выполняются медленнее из-за необходимости взаимодействия с внешними ресурсами и зависимостями.

> Хотя интеграционные тесты более сложны в написании и поддержке, они играют важную роль в обеспечении правильной работы системы в целом, проверяя, что все компоненты взаимодействуют правильно.

[Вернуться к началу статьи](#testing)

---

## TDD

> TDD (`Test-driven development`, разработка через тестирование) - это методология разработки программного обеспечения, основанная на создании тестов перед написанием кода.

> Согласно методологии TDD, разработчик должен написать тесты перед созданием кода, который будет проверяться этими тестами. Тесты должны проверять соответствие правильности работы кода предъявляемым требованиям и спецификациям. После написания тестов разработчик может приступить к написанию кода, чтобы успешно пройти все тесты. По завершении написания кода, разработчик запускает тесты, чтобы проверить, проходят ли они или нет.

> Процесс ТDD обладает несколькими преимуществами. Он позволяет уменьшить количество ошибок и ускорить процесс разработки, а также сохранять надежность и стабильность программного обеспечения. Кроме того, ТDD помогает при создании документации и может улучшить процесс взаимодействия команды разработки.

> TDD может быть применена на всех этапах разработки, включая архитектуру, проектирование, рефакторинг и тестирование. Важно придерживаться правильного порядка создания тестов, чтобы избежать незначительных ошибок и оптимизировать процесс тестирования.

[Вернуться к началу статьи](#testing)

---

## Regression bugs

> Регрессионные баги - это ошибки, которые возникают в уже исправленном или ранее работающем коде из-за внесенных изменений в другой части кода. Это могут быть ошибки, которые были исправлены ранее, но появились снова после внесения изменений.

> Чтобы избежать регрессионных багов, рекомендуется использовать автоматическое тестирование. Автоматические тесты позволяют определить, повлияло ли изменение кода на работу системы в целом, и обнаружить возможные проблемы, которые могут возникнуть из-за изменений.

> При каждом изменении кода, которое вносится в проект, автоматические тесты запускаются на все ключевые функции и компоненты системы. Если автоматический тест сообщает об ошибке, то это означает, что был внесен регрессионный баг и необходимо доработать код.

[Вернуться к началу статьи](#testing)

---

## Side effects

> Сайд-эффекты - это действия, выполняемые функцией, помимо возврата значения. Это могут быть операции записи в базу данных, изменение глобальной переменной, вывод на экран и другие действия, изменяющие состояние приложения.

> Эти действия могут ухудшить тестируемость кода, так как тестирование функции, имеющей сайд-эффект, может давать неожиданные результаты из-за изменения состояния других частей системы.

> Например, если тестируемая функция записывает данные в базу данных, то результат теста будет зависеть от состояния базы данных в момент запуска теста, а не только от входных данных, переданных в функцию. Это может привести к трудностям при отладке и следованию принципам “чистой функции”, когда функция ничего не меняет за пределами своей видимости.

[Вернуться к началу статьи](#testing)

---

## SPY

> В тестировании программного обеспечения, “шпионы” или “шпионские объекты” - это программный инструментарий, который может использоваться для сбора информации о выполнении тестируемого приложения.

> Шпионы могут быть полезными для тестирования, когда вы хотите получить дополнительную информацию о работе программы, такую как информацию о значениях переменных, вызванных функциях, и другие важные данные

> Однако, следует быть осторожным, так как применение шпионов в тестировании может нарушать безопасность или приватность данных, особенно при тестировании приложений, содержащих конфиденциальную информацию. Поэтому, использование шпионов следует оценивать в контексте конкретной тестируемой системы, и применять только после тщательного анализа рисков и с согласия ответственных лиц.

### Стоит ли тестировать приватные методы класса - это зависит от конкретного случая.

> В целом, тестирование приватных методов может быть полезным, так как это позволит удостовериться, что они работают корректно, и поможет предотвратить возможные проблемы в будущем. Также тестирование приватных методов может быть полезным для тестирования вспомогательных функций, которые не непосредственно используются извне, но играют важную роль в корректной работе программы.

> Однако, стоит учитывать, что приватные методы являются частью внутренней реализации класса и могут быть изменены или удалены без уведомления пользователей. Поэтому, при тестировании приватных методов следует быть осторожным и убедиться, что тестирование фактически испытывает полезную функциональность, а не только внутреннюю реализацию.

> Таким образом, тестирование приватных методов может быть полезным, в то же время не следует злоупотреблять ими и следует оценивать необходимость тестирования приватных методов в каждом конкретном случае.

[Вернуться к началу статьи](#testing)

---

## Boundary conditions

- Что такое граничные условия? Зачем их тестировать?

> `Граничные условия` - это значения входных данных, которые находятся на границе допустимых значений для функции или модуля. Зачастую на границах возможных значений программа ведет себя особенным образом или могут проявиться особенности реализации.

> Тестирование граничных условий является важной частью тестирования программного обеспечения по следующим причинам:

- Обнаружение ошибок: На границах значений часто возникают ошибки из-за неправильной обработки их программой. Тестирование граничных условий позволяет выявить такие ошибки.

- Повышение надежности: Тестирование граничных условий помогает убедиться, что программа корректно обрабатывает крайние входные данные и ведет себя предсказуемо.

- Улучшение качества кода: Работа с граничными условиями может помочь выявить слабые места в коде, что в свою очередь приведет к его улучшению.

> Таким образом, тестирование граничных условий является важным инструментом для обеспечения качества программного обеспечения и предотвращения непредвиденных ошибок

[Вернуться к началу статьи](#testing)

---

## Heisenbug

> `Heisenbug` - это термин, используемый в программировании для обозначения ошибки или дефекта, который пропадает или меняет свое поведение при попытке его изучить или исправить. Название Heisenbug происходит от того, что эта ошибка напоминает принцип неопределенности Гейзенберга из квантовой механики, по которому невозможно одновременно точно знать параметры частицы и ее скорость.

Для дебага Heisenbug'ов существуют различные подходы:

- Логирование: Добавление дополнительных логов в код для отслеживания состояния программы на различных этапах выполнения. Это может помочь выявить, где и почему происходит непредвиденное поведение.

- Регрессионное тестирование: Создание набора тестов, которые воспроизводят Heisenbug. После этого чередование действий с дебаггером и тестирование помогает выявить причину проблемы.

- Minimization: Попытка упростить проблему путем удаления частей кода или условий, чтобы сузить область поиска.

- Использование диагностических инструментов: Инструменты типа профайлеров, трассировщиков и статических анализаторов могут помочь обнаружить и идентифицировать Heisenbug'и.

- Pair programming: Совместное программирование с другими разработчиками может помочь при обнаружении и исправлении Heisenbug'ов благодаря дополнительным взглядам и опыту.

> Помните, что Heisenbug'и могут быть сложными для обнаружения и исправления из-за их нестабильного характера, поэтому терпение, методичный подход и коллективное участие могут быть ключевыми качествами в процессе их решения.

[Вернуться к началу статьи](#testing)

---

## Fixture

> `Фикстура (fixture)` в программировании обычно относится к предустановленным данным, объектам или состояниям, необходимым для выполнения тестов или операций.

> В контексте тестирования, фикстура - это набор начальных данных или контекста, который подготавливается перед запуском тестового случая. Фикстуры обычно используются для создания стабильной среды выполнения тестов, где известно, в каком состоянии будут находиться данные перед началом каждого теста.

> Например, если у вас есть тест, который проверяет функцию сортировки списка чисел, то фикстурой может быть сам список чисел, который будет предварительно отсортирован перед запуском теста.

> Фикстуры могут быть использованы для инициализации баз данных, создания временных файлов, настройки окружения или любых других действий, необходимых для корректного выполнения тестов.

> Фикстуры упрощают написание тестов и обеспечивают их независимость друг от друга, так как каждый тест будет выполняться в своей собственной, предопределенной среде.

> В различных тестовых фреймворках, таких как Pytest для Python или JUnit для Java, существуют специальные методы для создания и управления фикстурами в тестовых сценариях.

[Вернуться к началу статьи](#testing)

---

## Code coverage

> Покрытие кода тестами `(code coverage)` - это метрика, используемая для измерения объема исходного кода программы, который проверен тестами. Она показывает, какой процент инструкций, ветвлений, условий или функций был выполнен во время выполнения тестового комплекта. Чем выше уровень покрытия кода, тем больше частей кода проверено тестами.

Инструменты для анализа покрытия кода тестами включают в себя:

- JaCoCo: Популярный инструмент для измерения покрытия кода Java. Он поддерживает различные типы покрытия, такие как строковое покрытие, ветвления, инструкции и другие.

- Coverage.py: Инструмент для анализа покрытия кода в Python. Он позволяет измерять покрытие инструкций, ветвлений, функций и строк кода.

- LCOV: Утилита для сбора данных о покрытии тестов в формате, совместимом с отчетами в формате HTML, используемыми для отображения результатов покрытия.

- Cobertura: Инструмент для измерения покрытия кода в Java и других языках. Он генерирует отчеты в формате XML и HTML.

- stanbul/nyc: Для JavaScript проектов, istanbul является одним из наиболее распространенных инструментов для анализа покрытия кода, а nyc - команда для его запуска и отображения отчетов.

> Измерение покрытия кода тестами помогает разработчикам понять, насколько полно их код покрывается тестами, и выявить участки кода, которые требуют дополнительных тестов. Это помогает улучшить качество кода, устранить недостатки и повысить надежность программного обеспечения.

[Вернуться к началу статьи](#testing)

---

## Patterns

> Обращение внимания на закономерности при отказе тестов имеет большое значение в процессе разработки программного обеспечения и тестирования, так как может помочь в выявлении причин отказов и улучшении качества тестовой базы. Анализ того, какая именно комбинация тестов отвалилась, может принести следующие преимущества:

- Выявление зависимостей между тестами: Понимание того, какие тесты отказывают вместе и какие успешны вместе, позволяет выявить зависимости между тестами, а также между компонентами системы. Это может указать на потенциальные проблемы взаимодействия между компонентами или недостатки в тестовых сценариях.

- Уточнение причин отказа: Анализ комбинации отвалившихся тестов может помочь определить общую причину отказа, например, изменение в общей зависимости, ошибку в общем коде и т. д. Это упростит процесс исправления и улучшения тестов.

- Оптимизация тестов: Понимание, какие комбинации тестов чаще всего отваливаются, поможет определить уязвимые места тестовой базы. Это может послужить основой для оптимизации тестов, устранения избыточности или улучшения покрытия кода.

- Улучшение общей стабильности и качества кода: Анализ закономерностей при отказе тестов поможет выявить узкие места в системе или тестовой базе, что позволит принимать меры по улучшению стабильности и качества кода.

> В целом, анализ комбинаций тестов, которые отвалились, помогает выявить проблемы в системе и тестовой базе, оптимизировать процесс тестирования и улучшить качество разрабатываемого ПО.

[Вернуться к началу статьи](#testing)

---

## Tests-help-in-designing

> Тесты играют важную роль в проектировании ПО и являются неотъемлемой частью процесса разработки. Вот как тесты могут помочь в проектировании:

- Спецификация требований: Написание тестов позволяет разработчикам и заказчикам явно определить требования к системе. Тесты становятся спецификацией поведения модуля или системы.

- Итеративная разработка: Создание тестов позволяет проводить итерации разработки, постоянно проверяя работу нового кода и внося исправления на ранних этапах.

- Упрощение рефакторинга: Наличие тестов облегчает процесс рефакторинга кода, так как тесты помогают обнаружить нарушения в работе программы после внесения изменений.

- Документация кода: Тесты могут служить документацией к коду, поскольку они описывают ожидаемое поведение программы и демонстрируют, как использовать и тестировать отдельные компоненты.

> Тестируемость модуля, то есть способность модуля быть подвергнутым тестированию, является отличным индикатором "чистоты кода" по нескольким причинам:

- Высокая связность и низкая связанность: Чистый и хорошо спроектированный код обычно имеет высокую связность (одна задача - одна функция) и низкую связанность (минимальное взаимодействие с другими модулями). Это облегчает написание тестов, так как модуль можно тестировать изолированно.

- Ясность и прозрачность: Чистый код легче читать и понимать. Это упрощает разработку тестов, поскольку можно легче определить, что именно нужно протестировать.

- Минимизация побочных эффектов: Чистый код обычно имеет меньше побочных эффектов и зависимостей, что делает его более предсказуемым и легким в тестировании.

> Таким образом, обеспечение тестируемости модулей помогает не только улучшить качество и надежность кода, но и служит своего рода индикатором "чистоты" кодовой базы.

> Тесты являются полноправной частью системы и кодовой базы:

- `Качество и поддержка`: Тесты помогают поддерживать высокое качество кода, выявляя ошибки и недочеты на ранних стадиях разработки. Это существенно снижает вероятность появления дефектов в продакшне.

- `Документация`: Хорошо написанные тесты служат своего рода документацией для кода. Они показывают, как различные части системы должны работать и как они взаимодействуют друг с другом.

- `Изменяемость`: Тесты позволяют командам быстрее и безопаснее вносить изменения в кодовую базу. Разработчики могут уверенно добавлять новые функции или рефакторить старые, зная, что тесты помогут выявить возможные проблемы.

- `Непрерывная интеграция`: В современных процессах разработки тесты часто интегрируются в пайплайны CI/CD (непрерывной интеграции и непрерывного развертывания), что делает их неотъемлемой частью автоматизации сборки и развертывания.

[Вернуться к началу статьи](#testing)

---

## Libraries for creating and running tests

В Angular существует несколько библиотек и инструментов для создания и запуска тестов.

1. `Jasmine`:

- Это основная библиотека для написания юнит-тестов в Angular.
- Предоставляет простой и понятный синтаксис для написания тестов с использованием объектов describe, it, beforeEach и других.
- Используется в сочетании с Karma для запуска тестов.

2. `Karma`:

- Это тестовый раннер, который позволяет запускать тесты в различных браузерах.
- Обеспечивает быструю обратную связь во время разработки, так как автоматически перезапускает тесты при изменении кода.
- Хорошо интегрируется с Jasmine и другими тестовыми фреймворками.

3. `Protractor`:

- Это фреймворк для энд-то-энд тестирования приложений Angular и AngularJS.
- Позволяет писать тесты, которые взаимодействуют с приложением, как это делает пользователь, и проверяет, что все работает правильно.
- Использует Selenium WebDriver для управления браузерами и поддерживает асинхронные действия.

4. `TestBed`:

- Это утилита, которая входит в состав Angular Testing Framework для создания и настройки тестовой среды.
- Позволяет тестировать компоненты, сервисы и другие классы, предоставляя возможность легко настраивать зависимости и контексты тестирования.

5. `Cypress`:

- Это более современный инструмент для энд-то-энд тестирования, который стал популярным в последнее время.
- Предоставляет более удобный интерфейс и интерактивную отладку по сравнению с Protractor.
- Позволяет тестировать Angular-приложения, а также приложения на других фреймворках.

Основные отличия:

- `Назначение`: Jasmine и Karma предназначены для юнит-тестирования, в то время как Protractor и Cypress используются для энд-то-энд тестирования.
- `Интерфейс и удобство`: Cypress предлагает более современный и удобный интерфейс, в то время как Protractor может быть сложнее в настройке и использовании.
- `Асинхронность`: В Jasmine используется промисы для работы с асинхронным кодом, тогда как Cypress имеет встроенную поддержку асинхронных действий, что облегчает разработку тестов.

> Тесты могут значительно помочь новичкам при входе в проект по нескольким причинам.

- Тесты гарантируют, что изменения, вносимые новичками, не нарушают существующую функциональность.
- Читая тесты, они могут понять ожидания и требования к функциональности.
- Тесты помогают новичкам лучше понять архитектуру приложения и его основные компоненты.
- Наличие тестов придаёт новичкам уверенность в том, что их код будет проверен и протестирован.

> Тесты помогают в документировании проекта.

- Тесты описывают ожидаемое поведение программы, что делает их отличным источником информации о том, как система должна работать.
- Тесты могут служить практическими примерами, показывая, как использовать различные функции и методы.
- Когда в проект вносятся изменения, тесты могут удостовериться, что новая функциональность соответствует документации.
- Автоматизированные тесты, которые проверяют функциональность, могут служить заменой традиционной документации.

[Вернуться к началу статьи](#testing)

---

## Manual testing

> Ручное тестирование в Angular — это важная часть процесса обеспечения качества, и, несмотря на то что unit-тесты играют ключевую роль в автоматизации проверки базового функционала, некоторые этапы ручного тестирования могут помочь сократить необходимость в unit-тестах или дополнить их.

- Анализ требований и спецификаций
- Планирование тестирования
- Тестирование пользовательского интерфейса (UI)
- Проверка кросс-браузерной совместимости
- Функциональное тестирование

[Вернуться к началу статьи](#testing)

---

## Testing pyramid

> Пирамида тестирования — это концепция, которая иллюстрирует разные уровни тестирования программного обеспечения и показывает, как лучше распределять усилия тестирования для достижения наилучшего качества при наименьших затратах.

Основные уровни пирамиды тестирования:

1. `Юнит-тесты (Unit Tests)`:

- На самом нижнем уровне пирамиды находятся юнит-тесты. Это автоматизированные тесты, которые проверяют отдельные модули или компоненты кода в изоляции. Они позволяют разработчикам быстро выявлять ошибки и обеспечивать корректность низкоуровневой логики.

2. `Интеграционные тесты (Integration Tests)`:

- На следующем уровне располагаются интеграционные тесты, которые проверяют взаимодействие между модулями или компонентами системы. Эти тесты помогают выявить проблемы при интеграции различных частей приложения.

3. Системные тесты (System Tests):

- Далее идут системные тесты, которые проверяют всё приложение целиком, как оно работает в реальных условиях. Эти тесты подтверждают, что приложение выполняет требуемые функции и работает как ожидается.

4. `Приемочные тесты (Acceptance Tests)`:

- На верхнем уровне находятся приемочные тесты. Они проверяют всю систему с точки зрения пользователя и помогают убедиться, что приложение соответствует бизнес-требованиям и ожиданиям пользователей.

[Вернуться к началу статьи](#testing)

---

## End-to-end

> `End-to-end (E2E) тесты` — это тип тестирования программного обеспечения, который проверяет полную функциональность приложения, имитируя сценарии, которые могут выполнять реальные пользователи. Эти тесты охватывают все слои системы, включая пользовательский интерфейс, серверную часть, базу данных и внешние сервисы, чтобы убедиться, что они работают корректно вместе.

Основные характеристики E2E тестов:

- `Полный сценарий`: E2E тесты проверяют полный путь от начала до конца, например, от регистрации пользователя до оформления заказа на сайте.

- `Проверка бизнес-логики`: Они нацелены на подтверждение, что бизнес-требования выполняются и что пользователь получает ожидаемый результат.

- `Реальные условия`: E2E тесты обычно выполняются в среде, близкой к реальной, чтобы имитировать условия, в которых будет работать приложение.

- `Автоматизация`: Многие E2E тесты могут быть автоматизированы с помощью инструментов, таких как Selenium, Cypress и других, что помогает сэкономить время и усилия при тестировании.

Основные отличия `end-to-end` от `интеграционных тестов`:

1. Охват:

- `E2E тесты`: Проверяют полный сценарий использования приложения от начала до конца. Они имитируют действия реального пользователя и включают все слои системы — пользовательский интерфейс, серверную часть, базы данных и внешние API.

- `Интеграционные тесты`: Фокусируются на проверке взаимодействия между конкретными модулями или компонентами приложения. Они могут проверять, как несколько модулей работают вместе, не охватывая весь процесс от начала до конца.

2. Цель:

- `E2E тесты`: Основная цель — проверить, что бизнес-логика работает корректно и что пользователь получает ожидаемый результат, проходя весь сценарий. Они помогают удостовериться, что все части приложения интегрированы и функционируют так, как задумано. 📋✨

- `Интеграционные тесты`: Их цель — выявить проблемы, возникающие при взаимодействии между модулями, такие как ошибки в интерфейсах или неправильная передача данных. Они помогают убедиться, что компоненты корректно обмениваются информацией.

3. Уровень тестирования:

- `E2E тесты`: Обычно выполняются на высоком уровне, тестируя приложение в целом. Они могут включать в себя множество интеграционных взаимодействий, но с точки зрения пользовательского опыта. 🎯🌟

- `Интеграционные тесты`: Проводятся на более низком уровне, сосредоточены на проверке конкретных взаимодействий между модулями без учета общего пользовательского интерфейса.

[Вернуться к началу статьи](#testing)

---

## Test Double and Fake

> `Test Double` — это общий термин, который используется для обозначения любых объектов, которые заменяют реальные зависимости, чтобы сделать тесты более управляемыми и изолированными. Существуют разные типы Test Double, включая `Fake`, `Mock` и `Stub`.

1. Fake

- `Fake` — это реализация некоторого интерфейса или абстрактного класса, которая имеет упрощённое, но рабочее поведение. Fake-объекты обычно используются для замены реальных зависимостей в тестах, обеспечивая более простую логику, чем оригинал.

- Пример: Если у вас есть база данных, вы можете создать Fake, который сохраняет данные в памяти вместо реальной базы данных. Это полезно для ускорения тестов и снижения зависимости от внешней среды.

2. Stub:

- `Stub` — это объект, который предоставляет заранее определённые ответы на вызовы методов и не имеет никакой логики, помимо этого. Stubs обычно используются для возвращения фиксированных значений для тестов.

- Пример: Если ваш код обращается к службе API, вы можете использовать Stub для возврата заранее определённого ответа, чтобы протестировать логический поток без реального запроса к API.

3. Mock:

- `Mock`— это объект, который не только возвращает заранее определённые значения, но и позволяет проверять взаимодействия с ним. Вы можете настраивать ожидания по отношению к методам, проверять, были ли они вызваны, и сколько раз.

- `Пример`: Если ваш тест ожидает, что определённый метод будет вызван, вы можете настроить Mock для проверки этого ожидания, что позволяет убедиться, что код работает правильно и взаимодействует с зависимостями, как требуется.

Вкратце:

- `Fake`: реализация с простым, но рабочим поведением.
- `Stub`: объект, который предоставляет фиксированные ответы без логики.
- `Mock`: объект, который проверяет взаимодействия и ожидает вызовы методов.

> Применение `Mocks` действительно упрощает проектирование методом `outside-in` (снаружи внутрь) благодаря нескольким ключевым аспектам.

- `Изоляция компонентов`: Mocks позволяют изолировать тестируемые компоненты, что помогает сосредоточиться на функциональности верхнего уровня без необходимости заботиться о реализации нижележащих зависимостей. Это значит, что можно тестировать поведение системы на более высоком уровне.

- `Контроль над окружающей средой`: С помощью Mocks можно создатьControlled environment (управляемую среду) для тестирования, что позволяет получать предсказуемые и повторяемые результаты. Это особенно важно при тестировании внешних зависимостей, таких как базы данных или API.

- `Снижение сложности`: Использование Mocks помогает упростить тесты, так как они заменяют реальные объекты, обеспечивая простые и быстрые проверки без необходимости инициализировать сложные зависимости. Это позволяет сосредоточиться на логике тестируемого модуля.

- `Поддержка принципов TDD`: Метод "outside-in" часто используется в подходе тестирования через проектирование (TDD). Mocks позволяют разрабатывать тесты до написания кода, обеспечивая при этом гибкость в проектировании системы, так как можно легко вносить изменения в интерфейсы, не затрагивая логику тестов.

- `Упрощение эволюции системы`: При использовании Mocks можно легче адаптировать и изменять архитектуру системы, так как тесты, основанные на Mocks, меньше зависят от реализации. Это помогает вносить изменения в функционал без значительного переосмысления существующих тестов.

[Вернуться к началу статьи](#testing)

---

## Behavior and state verification

> Тестирование с использованием `behavior verification` (проверка поведения) и `state verification` (проверка состояния) — это два разных подхода к тестированию, которые используются для проверки правильности работы кода.

1. `Behavior Verification` (Проверка поведения):

- Этот подход сосредоточен на том, как объект взаимодействует с другими объектами и какие методы вызываются.
- При использовании проверки поведения вы проверяете, что определённые методы были вызваны с ожидаемыми аргументами. Это важно для проверки того, что компонент взаимодействует с зависимостями так, как вы ожидали.
- Чаще всего используются Mocks для реализации такого подхода, так как они позволяют настраивать ожидания по поводу вызовов методов.
- Пример: Вы проверяете, что метод processOrder вызывал метод sendNotification с правильными параметрами.

2. `State Verification` (Проверка состояния):

- Этот подход сосредоточен на проверке состояния объекта после выполнения определённых действий. Вы проверяете, что объект находится в ожидаемом состоянии после выполнения теста.
- При использовании проверки состояния вы часто используете Stubs или настоящие объекты, чтобы выполнить необходимые действия и затем проверяете состояние.
- Пример: Вы проверяете, что после вызова метода processOrder число заказов увеличилось на единицу.

Краткое сравнение:

- Behavior Verification:

  - Проверяет взаимодействие между объектами и вызовы методов.
  - Склонен использовать Mocks.
  - Фокус на том, как что-то происходит.

- State Verification:

  - Проверяет состояние объекта после выполнения действий.
  - Обычно использует Stubs или настоящие объекты.
  - Фокус на том, что происходит в результате.

### Почему применение Mocks провоцирует behavior verification?

1. Контроль над взаимодействием:

- Mocks позволяют вам точно настроить, какие методы должны быть вызваны, и с какими аргументами. Это контроль дает возможность тестировать ожидаемое поведение системы.
- Например, вы можете создать Mock-объект, который ожидает вызов метода с конкретными параметрами, и ваш тест будет успешным только в том случае, если это взаимодействие произошло.

2. Изоляция тестируемого кода:

- Использование Mocks помогает изолировать тестируемую единицу (например, класс или метод) от её зависимостей. Это позволяет сосредоточиться на поведении, а не на состоянии.
- Поскольку Mock-объекты замещают реальные зависимости, вы можете тестировать только то, как ваш объект взаимодействует с ними, игнорируя то, что происходит внутри самих зависимостей.

3. Упрощение проверки сложных взаимодействий:

- В сложных системах может быть несколько взаимозависимых объектов. Mocks упрощают тестирование сложных взаимодействий, позволяя вам проверять, какие методы были вызваны и в каком порядке.
- Это важно в системах с множеством состояний и переходов, где проверка поведения является более показательным и полезным подходом, чем проверка состояния.

4. Документирование намерений:

- Использование Mocks делает ваши тесты более самодокументированными. Когда вы видите, что тест ожидает вызов метода на Mock-объекте, это сразу дает понять, какое взаимодействие предполагается между объектами.
- Это помогает разработчикам быстро разобраться в том, как система должна работать и какие зависимости между объектами существуют.

[Вернуться к началу статьи](#testing)

---

## Solitary and Sociable tests

> Тесты `Solitary` (одиночные) и `Sociable` (социальные) часто используются для определения типов личности и предпочтений в социальных взаимодействиях.

- `Solitary тесты`: Эти тесты выявляют предпочтение человека к одиночеству или к более интровертному стилю жизни. Люди, у которых высокие результаты в таких тестах, обычно предпочитают проводить время в уединении, занимаются индивидуальными увлечениями и могут находить комфорт в уединении.

- `Sociable тесты`: Эти тесты направлены на определение уровня экстраверсии. Люди с высокими результатами в социальных тестах склонны к активным социальным взаимодействиям, предпочитают проводить время в компании других людей и активно участвуют в общественных мероприятиях.

Преимущества `Solitary` тестов включают в себя:

- `Личностное понимание`: Они помогают лучше понять свои предпочтения и потребности, что может способствовать личному росту и самосознанию.

- `Фокус на индивидуальных увлечениях`: Такие тесты могут выявить сильные стороны и интересы, которые проявляются в одиночной деятельности, позволяя сосредоточиться на хобби и проектах, которые приносят радость.

- `Улучшение навыков самообслуживания`: Понимание своего предпочтения к одиночеству может помочь развить навыки самообслуживания и улучшить эмоциональное благополучие.

- `Планирование времени`: Зная свои склонности, легче планировать время, распределяя занятия между активностями в одиночку и социальными взаимодействиями, чтобы избежать перегрузки.

- `Снижение стресса`: Для интровертов совместные мероприятия могут вызывать стресс. Solitary тесты могут помочь минимизировать ситуации, которые вызывают дискомфорт.

`Sociable` тестов тоже есть множество преимуществ:

- `Социальное взаимодействие`: Они помогают выявить склонности к общению и взаимодействию с другими, что может улучшить навыки общения и построения отношений.

- `Командная работа`: Sociable тесты способствуют пониманию своих предпочтений в командной среде, что может повысить эффективность совместной работы и сотрудничества.

- `Сеть контактов`: Узнавая о своих социальных предпочтениях, можно легче устанавливать новые связи и строить полезные знакомства в профессиональной и личной жизни.

- `Повышение уверенности`: Знание своих социальных сильных сторон может увеличить уверенность в себе, что в свою очередь улучшает качество коммуникации с другими людьми.

- `Эмоциональное благополучие`: Социальные связи играют важную роль в эмоциональном здоровье, и такие тесты могут помочь определить, как лучше наладить и поддерживать эти связи.

[Вернуться к началу статьи](#testing)

---
