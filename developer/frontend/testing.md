# Testing

- [Unit-test](#unit-test)
- [Integration testing](#integration-testing)
- [Чем юнит-тесты отличаются от интеграционных тестов?](#unit-test-and-integration-testing)
- [TDD](#tdd)
- [Regression bugs](#regression-bugs)
- [Side effects](#side-effects)
- [SPY](#spy)
- [Что такое граничные условия?](#boundary-conditions)
- [Что такое heisenbug? Какие есть способы их дебаггинга?](#heisenbug)
- [Что такое fixture?](#fixture)
- [Что такое покрытие кода тестами?](#code-coverage)
- [Закономерности при отказе тестов](#patterns)
- [Как тесты помогают в проектировании?](#tests-help-in-designing)

## Unit-test

> Unit-тестирование - это процесс проверки корректности работы отдельных, изолированных единиц кода, таких как функций, классов или методов.

> Целью unit-тестирования является измерение качества и надежности кода, а также уменьшение количества ошибок, которые могут возникнуть при работе программы в процессе разработки. Тестирование каждой единицы кода производится отдельно, без взаимодействия с другими модулями или зависимостями.

> Как правило, unit-тесты создаются в виде специальных функций, которые проверяют поведение отдельных модулей.
> Тесты могут включать в себя определенные значения, которые ожидаются от функции при определенных условиях, например, входные параметры. Проверка выполняется с помощью assert-операторов, которые определяют соответствие между ожидаемыми значениями и фактическими результатами.

```javascript
function sum(a, b) {
	return a + b
}

function test() {
	assert(sum(1, 2) === 3)
	assert(sum(0, 0) === 0)
	assert(sum(-1, 1) === 0)
}

test()
```

### Группирование отдельных тестов внутри unit-тестов имеет несколько преимуществ:

- `Читаемость тестов`: Группирование повышает читаемость тестов, поскольку сгруппированные тесты могут описывать схожие функции.
- `Поддерживаемость тестов`: Группирование тестов облегчает поддержку тестов в долгосрочной перспективе. Тестирование сгруппированных тестов легче поддается изменениям и разработчики могут быстрее обнаружить, если определенные изменения неправильно повлияли на группу тестов.
- `Включение и исключение тестов из запуска`: Группирование тестов позволяет включать или исключать определенные группы тестов.
- `Повторное использование тестов`: Группирование тестов облегчает повторное использование кусков кода, который группируется и может использоваться в других тестовых наборах.
- `Масштабируемость`: Группирование тестов облегчает масштабирование тестов и позволяет эффективно добавлять новые тесты при необходимости.

В целом, группирование отдельных тестов внутри unit-тестов помогает упростить и упорядочить тестирование, повышает его эффективность и облегчает его поддержку.

[Вернуться к началу статьи](#testing)

---

## Integration testing

> Интеграционное тестирование - это процесс проверки успешной работы взаимодействия между различными компонентами системы, такими как базы данных, серверные API, пользовательские интерфейсы и другие. Целью интеграционного тестирования является проверка корректности и правильности работы системы в целом

> При интеграционном тестировании проверяется, как работает взаимодействие между компонентами, запущенными вместе в реальном окружении. Основным принципом интеграционного тестирования является проверка “черного ящика”, когда тестируется только выходной результат системы при заданных входных параметрах и условиях.

> Тесты могут быть выполнены как автоматически, так и вручную. Автоматические тесты могут включать в себя сценарии использования, которые проверяют работу с конечным пользователем и проверку взаимодействия компонентов системы, начиная от самых простых до наиболее сложных. Также могут проводиться эмуляции и симуляции системного окружения для проверки взаимодействия между компонентами.

[Вернуться к началу статьи](#testing)

---

## Unit test and Integration testing

> Юнит-тесты и интеграционные тесты являются двумя основными типами тестирования в разработке программного обеспечения.

Юнит-тесты:

- Цель: Проверить отдельные части кода (обычно функции, методы, классы) изолированно от других компонентов системы.
- Особенности: Обычно используют заглушки (mocks) или стабы для имитации зависимостей.
- Преимущества: Быстрота выполнения, можно легко автоматизировать, помогают обнаруживать и исправлять ошибки в ранней стадии разработки.
- Недостатки: Могут не обнаружить проблемы интеграции между компонентами.

Интеграционные тесты:

- Цель: Проверить, как отдельные компоненты взаимодействуют между собой и правильно ли работает система в целом.
- Особенности: Тестируют сценарии использования, интеграцию между различными частями программы или между различными сервисами.
- Преимущества: Обнаруживают проблемы взаимодействия между компонентами, проверяют, что все работает вместе правильно.
- Недостатки: Сложнее настроить и писать, требуют больше времени для запуска, могут быть менее надежными из-за многочисленных зависимостей.

Интеграционные тесты сложнее написать и поддерживать по нескольким причинам:

- Зависимости между компонентами: Интеграционные тесты требуют наличия всех зависимостей и необходимой среды выполнения, что усложняет их настройку.
- Сложность сценариев: Настройка сценариев для тестирования интеграции между различными компонентами может быть сложной и требует тщательного планирования.
- Скорость выполнения: Интеграционные тесты выполняются медленнее из-за необходимости взаимодействия с внешними ресурсами и зависимостями.

> Хотя интеграционные тесты более сложны в написании и поддержке, они играют важную роль в обеспечении правильной работы системы в целом, проверяя, что все компоненты взаимодействуют правильно.

[Вернуться к началу статьи](#testing)

---

## TDD

> TDD (`Test-driven development`, разработка через тестирование) - это методология разработки программного обеспечения, основанная на создании тестов перед написанием кода.

> Согласно методологии TDD, разработчик должен написать тесты перед созданием кода, который будет проверяться этими тестами. Тесты должны проверять соответствие правильности работы кода предъявляемым требованиям и спецификациям. После написания тестов разработчик может приступить к написанию кода, чтобы успешно пройти все тесты. По завершении написания кода, разработчик запускает тесты, чтобы проверить, проходят ли они или нет.

> Процесс ТDD обладает несколькими преимуществами. Он позволяет уменьшить количество ошибок и ускорить процесс разработки, а также сохранять надежность и стабильность программного обеспечения. Кроме того, ТDD помогает при создании документации и может улучшить процесс взаимодействия команды разработки.

> TDD может быть применена на всех этапах разработки, включая архитектуру, проектирование, рефакторинг и тестирование. Важно придерживаться правильного порядка создания тестов, чтобы избежать незначительных ошибок и оптимизировать процесс тестирования.

[Вернуться к началу статьи](#testing)

---

## Regression bugs

> Регрессионные баги - это ошибки, которые возникают в уже исправленном или ранее работающем коде из-за внесенных изменений в другой части кода. Это могут быть ошибки, которые были исправлены ранее, но появились снова после внесения изменений.

> Чтобы избежать регрессионных багов, рекомендуется использовать автоматическое тестирование. Автоматические тесты позволяют определить, повлияло ли изменение кода на работу системы в целом, и обнаружить возможные проблемы, которые могут возникнуть из-за изменений.

> При каждом изменении кода, которое вносится в проект, автоматические тесты запускаются на все ключевые функции и компоненты системы. Если автоматический тест сообщает об ошибке, то это означает, что был внесен регрессионный баг и необходимо доработать код.

[Вернуться к началу статьи](#testing)

---

## Side effects

> Сайд-эффекты - это действия, выполняемые функцией, помимо возврата значения. Это могут быть операции записи в базу данных, изменение глобальной переменной, вывод на экран и другие действия, изменяющие состояние приложения.

> Эти действия могут ухудшить тестируемость кода, так как тестирование функции, имеющей сайд-эффект, может давать неожиданные результаты из-за изменения состояния других частей системы.

> Например, если тестируемая функция записывает данные в базу данных, то результат теста будет зависеть от состояния базы данных в момент запуска теста, а не только от входных данных, переданных в функцию. Это может привести к трудностям при отладке и следованию принципам “чистой функции”, когда функция ничего не меняет за пределами своей видимости.

[Вернуться к началу статьи](#testing)

---

## SPY

> В тестировании программного обеспечения, “шпионы” или “шпионские объекты” - это программный инструментарий, который может использоваться для сбора информации о выполнении тестируемого приложения.

> Шпионы могут быть полезными для тестирования, когда вы хотите получить дополнительную информацию о работе программы, такую как информацию о значениях переменных, вызванных функциях, и другие важные данные

> Однако, следует быть осторожным, так как применение шпионов в тестировании может нарушать безопасность или приватность данных, особенно при тестировании приложений, содержащих конфиденциальную информацию. Поэтому, использование шпионов следует оценивать в контексте конкретной тестируемой системы, и применять только после тщательного анализа рисков и с согласия ответственных лиц.

### Стоит ли тестировать приватные методы класса - это зависит от конкретного случая.

> В целом, тестирование приватных методов может быть полезным, так как это позволит удостовериться, что они работают корректно, и поможет предотвратить возможные проблемы в будущем. Также тестирование приватных методов может быть полезным для тестирования вспомогательных функций, которые не непосредственно используются извне, но играют важную роль в корректной работе программы.

> Однако, стоит учитывать, что приватные методы являются частью внутренней реализации класса и могут быть изменены или удалены без уведомления пользователей. Поэтому, при тестировании приватных методов следует быть осторожным и убедиться, что тестирование фактически испытывает полезную функциональность, а не только внутреннюю реализацию.

> Таким образом, тестирование приватных методов может быть полезным, в то же время не следует злоупотреблять ими и следует оценивать необходимость тестирования приватных методов в каждом конкретном случае.

[Вернуться к началу статьи](#testing)

---

## Boundary conditions

- Что такое граничные условия? Зачем их тестировать?

> `Граничные условия` - это значения входных данных, которые находятся на границе допустимых значений для функции или модуля. Зачастую на границах возможных значений программа ведет себя особенным образом или могут проявиться особенности реализации.

> Тестирование граничных условий является важной частью тестирования программного обеспечения по следующим причинам:

- Обнаружение ошибок: На границах значений часто возникают ошибки из-за неправильной обработки их программой. Тестирование граничных условий позволяет выявить такие ошибки.

- Повышение надежности: Тестирование граничных условий помогает убедиться, что программа корректно обрабатывает крайние входные данные и ведет себя предсказуемо.

- Улучшение качества кода: Работа с граничными условиями может помочь выявить слабые места в коде, что в свою очередь приведет к его улучшению.

> Таким образом, тестирование граничных условий является важным инструментом для обеспечения качества программного обеспечения и предотвращения непредвиденных ошибок

[Вернуться к началу статьи](#testing)

---

## Heisenbug

> `Heisenbug` - это термин, используемый в программировании для обозначения ошибки или дефекта, который пропадает или меняет свое поведение при попытке его изучить или исправить. Название Heisenbug происходит от того, что эта ошибка напоминает принцип неопределенности Гейзенберга из квантовой механики, по которому невозможно одновременно точно знать параметры частицы и ее скорость.

Для дебага Heisenbug'ов существуют различные подходы:

- Логирование: Добавление дополнительных логов в код для отслеживания состояния программы на различных этапах выполнения. Это может помочь выявить, где и почему происходит непредвиденное поведение.

- Регрессионное тестирование: Создание набора тестов, которые воспроизводят Heisenbug. После этого чередование действий с дебаггером и тестирование помогает выявить причину проблемы.

- Minimization: Попытка упростить проблему путем удаления частей кода или условий, чтобы сузить область поиска.

- Использование диагностических инструментов: Инструменты типа профайлеров, трассировщиков и статических анализаторов могут помочь обнаружить и идентифицировать Heisenbug'и.

- Pair programming: Совместное программирование с другими разработчиками может помочь при обнаружении и исправлении Heisenbug'ов благодаря дополнительным взглядам и опыту.

> Помните, что Heisenbug'и могут быть сложными для обнаружения и исправления из-за их нестабильного характера, поэтому терпение, методичный подход и коллективное участие могут быть ключевыми качествами в процессе их решения.

[Вернуться к началу статьи](#testing)

---

## Fixture

> `Фикстура (fixture)` в программировании обычно относится к предустановленным данным, объектам или состояниям, необходимым для выполнения тестов или операций.

> В контексте тестирования, фикстура - это набор начальных данных или контекста, который подготавливается перед запуском тестового случая. Фикстуры обычно используются для создания стабильной среды выполнения тестов, где известно, в каком состоянии будут находиться данные перед началом каждого теста.

> Например, если у вас есть тест, который проверяет функцию сортировки списка чисел, то фикстурой может быть сам список чисел, который будет предварительно отсортирован перед запуском теста.

> Фикстуры могут быть использованы для инициализации баз данных, создания временных файлов, настройки окружения или любых других действий, необходимых для корректного выполнения тестов.

> Фикстуры упрощают написание тестов и обеспечивают их независимость друг от друга, так как каждый тест будет выполняться в своей собственной, предопределенной среде.

> В различных тестовых фреймворках, таких как Pytest для Python или JUnit для Java, существуют специальные методы для создания и управления фикстурами в тестовых сценариях.

[Вернуться к началу статьи](#testing)

---

## Code coverage

> Покрытие кода тестами `(code coverage)` - это метрика, используемая для измерения объема исходного кода программы, который проверен тестами. Она показывает, какой процент инструкций, ветвлений, условий или функций был выполнен во время выполнения тестового комплекта. Чем выше уровень покрытия кода, тем больше частей кода проверено тестами.

Инструменты для анализа покрытия кода тестами включают в себя:

- JaCoCo: Популярный инструмент для измерения покрытия кода Java. Он поддерживает различные типы покрытия, такие как строковое покрытие, ветвления, инструкции и другие.

- Coverage.py: Инструмент для анализа покрытия кода в Python. Он позволяет измерять покрытие инструкций, ветвлений, функций и строк кода.

- LCOV: Утилита для сбора данных о покрытии тестов в формате, совместимом с отчетами в формате HTML, используемыми для отображения результатов покрытия.

- Cobertura: Инструмент для измерения покрытия кода в Java и других языках. Он генерирует отчеты в формате XML и HTML.

- stanbul/nyc: Для JavaScript проектов, istanbul является одним из наиболее распространенных инструментов для анализа покрытия кода, а nyc - команда для его запуска и отображения отчетов.

> Измерение покрытия кода тестами помогает разработчикам понять, насколько полно их код покрывается тестами, и выявить участки кода, которые требуют дополнительных тестов. Это помогает улучшить качество кода, устранить недостатки и повысить надежность программного обеспечения.

[Вернуться к началу статьи](#testing)

---

## Patterns

> Обращение внимания на закономерности при отказе тестов имеет большое значение в процессе разработки программного обеспечения и тестирования, так как может помочь в выявлении причин отказов и улучшении качества тестовой базы. Анализ того, какая именно комбинация тестов отвалилась, может принести следующие преимущества:

- Выявление зависимостей между тестами: Понимание того, какие тесты отказывают вместе и какие успешны вместе, позволяет выявить зависимости между тестами, а также между компонентами системы. Это может указать на потенциальные проблемы взаимодействия между компонентами или недостатки в тестовых сценариях.

- Уточнение причин отказа: Анализ комбинации отвалившихся тестов может помочь определить общую причину отказа, например, изменение в общей зависимости, ошибку в общем коде и т. д. Это упростит процесс исправления и улучшения тестов.

- Оптимизация тестов: Понимание, какие комбинации тестов чаще всего отваливаются, поможет определить уязвимые места тестовой базы. Это может послужить основой для оптимизации тестов, устранения избыточности или улучшения покрытия кода.

- Улучшение общей стабильности и качества кода: Анализ закономерностей при отказе тестов поможет выявить узкие места в системе или тестовой базе, что позволит принимать меры по улучшению стабильности и качества кода.

> В целом, анализ комбинаций тестов, которые отвалились, помогает выявить проблемы в системе и тестовой базе, оптимизировать процесс тестирования и улучшить качество разрабатываемого ПО.

[Вернуться к началу статьи](#testing)

---

## Tests-help-in-designing

> Тесты играют важную роль в проектировании ПО и являются неотъемлемой частью процесса разработки. Вот как тесты могут помочь в проектировании:

- Спецификация требований: Написание тестов позволяет разработчикам и заказчикам явно определить требования к системе. Тесты становятся спецификацией поведения модуля или системы.

- Итеративная разработка: Создание тестов позволяет проводить итерации разработки, постоянно проверяя работу нового кода и внося исправления на ранних этапах.

- Упрощение рефакторинга: Наличие тестов облегчает процесс рефакторинга кода, так как тесты помогают обнаружить нарушения в работе программы после внесения изменений.

- Документация кода: Тесты могут служить документацией к коду, поскольку они описывают ожидаемое поведение программы и демонстрируют, как использовать и тестировать отдельные компоненты.

> Тестируемость модуля, то есть способность модуля быть подвергнутым тестированию, является отличным индикатором "чистоты кода" по нескольким причинам:

- Высокая связность и низкая связанность: Чистый и хорошо спроектированный код обычно имеет высокую связность (одна задача - одна функция) и низкую связанность (минимальное взаимодействие с другими модулями). Это облегчает написание тестов, так как модуль можно тестировать изолированно.

- Ясность и прозрачность: Чистый код легче читать и понимать. Это упрощает разработку тестов, поскольку можно легче определить, что именно нужно протестировать.

- Минимизация побочных эффектов: Чистый код обычно имеет меньше побочных эффектов и зависимостей, что делает его более предсказуемым и легким в тестировании.

> Таким образом, обеспечение тестируемости модулей помогает не только улучшить качество и надежность кода, но и служит своего рода индикатором "чистоты" кодовой базы.

[Вернуться к началу статьи](#testing)

---
