# TypeScript

- [Что такое TypeScript](#typescript)
- [Виды типизации](#typing)
- [Типы данных в TypeScript](#typing-in-typescript)
- [Модификаторы доступа. Access Modifiers](#access-modifiers)
- [Приведение типов. Type Assertions](#type-assertions)
- [Интерфейсы в TypeScript](#interface-in-typescript)
- [Определение типов в TypeScript. Type Aliases](#type-aliases-in-typescript)
- [Смешанные типы. Hybrid Types](#hybrid-types)
- [Индексные типы. Index Types](#index-types)
- [Сопоставленные типы. Mapped Types](#mapped-types)
- [Generic types](#generic-types)
- [Union и intersection типы](#union-and-intersection-type)
- [Type Guards](#type-guards)
- [Функции утверждения. Assertion Functions](#assertion-functions)
- [Декораторы в TypeScript](#decorators-in-typescript)
- [Перегрузка функции в TypeScript](#function-overload)
- [Типизация конструктора класса](#typing-class-constructor)
- [Утверждение const](#const-assertion)
- [Назначение типов](#assigning-types)
- [Условные типы](#conditional-types)
- [Type soundness и Type safety](#type-soundness-and-type-safety)
- [Structural typing](#structural-typing)
- [Declarations merging](#declarations-merging)
- [Compatibility (совместимость)](#compatibility)
- [Type variance (вариантность типов)](#type-variance)
- [Type Widening](#type-widening)
- [Fresh object literal type](#fresh-object-literal-type)
- [Refinement](#refinement)
- [Companion Object Pattern](#companion-object-pattern)
- [Вывод типов в TypeScript](#type-output-in-typescript)
- [Полиморфизм в TypeScript](#polymorphism-in-typescript)

## TypeScript

> TypeScript - это язык программирования, который представляет собой расширение языка JavaScript и добавляет статическую типизацию. Он разработан компанией Microsoft и является open-source.

> TypeScript был создан для того, чтобы помочь разработчикам более безопасно разрабатывать сложные проекты на JavaScript. Он позволяет задавать типы переменных, функций, интерфейсов, классов и других элементов, что уменьшает количество ошибок во время исполнения кода, такие как TypeError или ReferenceError.

Основные проблемы TypeScript, которые он помогает решить, это:

- Большое количество ошибок во время выполнения кода на JavaScript.
- Поддержка и развитие крупных проектов на JavaScript.
- Модульность и удобство чтения кода.
- Возможность использовать новые функции.

[Вернуться к началу статьи](#typescript)

---

## Typing

Выделяют несколько видов типизации:

1. Слабая и сильная (Строгая и нестрогая) типизация.

   > Сильная (строгая) типизация - это подход, который предполагает, что переменные имеют фиксированный тип и не могут быть изменены в процессе выполнения программы. В языках с такой типизацией (например, Java или C++) компилятор проверяет соответствие типов переменных еще на стадии компиляции и не позволит выполнить неправильные операции.

   > С другой стороны, слабая (нестрогая) типизация - это подход, в котором переменные не имеют фиксированного типа, а тип переменной определяется только во время выполнения программы. Примеры языков со слабой типизацией включают Python, JavaScript и PHP.

   > Плюсом слабой типизации является более гибкий и быстрый код за счет возможности переиспользования переменных под разные типы, а также большая гибкость при работе с динамическими данными. Однако этот подход склонен к ошибкам во время выполнения программы, так как проверка типов не происходит на этапе компиляции.

2. Статическая и динамическая типизация

   > Статическая типизация - это подход, при котором тип переменных фиксирован и определяется на стадии компиляции программы. Языки, использующие этот подход, например, Java и C++, требуют явного указания типа переменной.

   > Динамическая типизация - это подход, при котором тип переменных может меняться во время выполнения программы. Примеры таких языков включают Python, Ruby и JavaScript

   > Преимуществом статической типизации является возможность обнаружения ошибок на этапе компиляции, что делает код более безопасным и надежным. Недостатком статической типизации является то, что она может сделать код более громоздким.

   > Динамическая типизация имеет преимущество в удобстве и гибкости, но увеличивает время отладки, так как ошибки типов не обнаруживаются на этапе компиляции.

3. Явная и неявная типизация

   > Явная типизация - это подход, при котором тип переменной указывается явно при определении переменной. Примеры языков с явной типизацией включают Java, C++ и C#.

   > Неявная типизация - это подход, при котором тип переменной определяется автоматически компилятором на основе значения переменной. Примеры языков с неявной типизацией - Python, JavaScript и Ruby.

   > Преимуществом явной типизации является обеспечение безопасности и достоверности кода, так как компилятор проверяет типы переменных на этапе компиляции. Недостатком явной типизации является то, что она может быть громоздкой и затратной в использовании.

   > Неявная типизация обеспечивает более легкое и быстрое написание кода, так как не требует указания типов переменных при объявлении. Однако это увеличивает потенциальный риск ошибок типов в процессе выполнения программы.

4. Структурная и номинативная типизация
   > Структурная типизация - это типаж, при котором тип определяется только структурой.

### ВАЖНО!!!

> JavaScript использует слабую и динамическую типизацию, а также неявную и структурную типизацию. Это означает, что тип переменной определяется во время выполнения программы и может меняться, а тип переменной может быть определен автоматически компилятором на основе значения переменной.

> TypeScript, напротив, использует сильную и статическую типизацию со строгим контролем компилятора на этапе компиляции. Это означает, что типы компонентов приложения определяются заранее и фиксируются на этапе компиляции, что позволяет избежать ошибок во время выполнения. TypeScript также поддерживает явную и номинативную типизацию, где тип переменной задается явно при объявлении, и тип сравнивается с номинальным типом компонента, который задается в определении интерфейсов в TypeScript.

### ВАЖНО!!!

> Еще TypeScript есть два способа типизации классов - это типизация `static-side` и типизация `instance-side`.

- `Static-side` - типизация относится к свойствам и методам класса, которые доступны напрямую через класс, а не через его экземпляр. Для типизации `static-side` используется статический класс, который может содержать статические свойства и методы. В статических методах `this` указывает на тип класса.

```typescript
class Person {
	static species = 'Homo sapiens'
	static getName() {
		return 'Person'
	}

	constructor(public name: string, public age: number) {}
}

console.log(Person.species) // Homo sapiens
console.log(Person.getName()) // Person
```

- `Instance-side` типизация относится к свойствам и методам объектов, созданных из класса. Для типизации instance-side используется интерфейс класса. В интерфейсе перечисляются свойства и методы, которые являются частью экземпляра класса.

```typescript
interface PersonInterface {
	name: string
	age: number
	sayHello(): void
}

class Person implements PersonInterface {
	constructor(public name: string, public age: number) {}

	sayHello() {
		console.log(`Hello, my name is ${this.name}, and I am ${this.age} years old`)
	}
}

const person = new Person('Alice', 25)
person.sayHello() // Hello, my name is Alice, and I am 25 years old
```

[Вернуться к началу статьи](#typescript)

---

## Typing in TypeScript

В TypeScript используются следующие типы данных и для разных целей:

- `Boolean` - тип данных, который может иметь два значения true и false. Он используется для логических выражений, например, для проверки условий.
- `Number` - тип данных, который представляет числа, как целые, так и дробные. Он используется для математических вычислений и других операций, где требуется числовой тип.
- `String` - тип данных, который используется для представления символьных строк. Он используется для хранения текстовых данных, например, для подписей или описаний.
- `Bigint` - крупные целочисленные значения (1234n).
- `Null and Undefined` - это специальные типы данных, которые описывают отсутствие значения. Null используется, когда переменной должно быть явно присвоено отсутствующее значение, а Undefined - когда переменная не была инициализирована.
- `Object` - тип данных, который используется для представления объектов с определенным набором свойств. Он используется, когда требуется сложный тип данных, который может иметь много свойств.
- `Array` - тип данных, который используется для представления массивов, то есть упорядоченных наборов элементов одного типа данных.
- `Tuple` - специальный тип данных, который позволяет задавать массивы фиксированной длины и фиксированного состава элементов. (`let variable:[string, string, number] = [ «malcolm», «gladwell», 1963 ]`)
- `Enum` - тип данных, который позволяет присваивать имена числовым значениям. Он используется для удобства работы с числовыми кодами, например, при работе со статусами заказа.
- `Any` - тип данных, который может иметь любое значение и не проходит проверку на этапе компиляции. Он используется для неопределенных данных, когда точный тип невозможен или неизвестен.
- `Void` - тип данных, который используется для определения функций, которые не возвращают значения.
- `Never` - тип данных, который описывает ситуации, когда функция не может завершиться или генерировать исключения.
- `Unknown` - тип данных, который появился в TypeScript 3.0 и является более строгой альтернативой типу Any. Он используется, когда вы точно не знаете, какой тип данных будет передан, но вы хотите, чтобы значение было проверено на этапе компиляции.

[Вернуться к началу статьи](#typescript)

---

## Access Modifiers

В TypeScript актуальны четыре модификатора свойств классов:

1. `public` - свойства и методы с модификатором `public` доступны из любой части приложения. По умолчанию все свойства и методы являются `public`, если явно не указан другой модификатор.
2. `private` - свойства и методы с модификатором `private` недоступны извне класса. Они могут быть использованы только внутри самого класса. Даже напрямую обратиться к приватному свойству или методу невозможно.
3. `protected` - свойства и методы с модификатором `protected` доступны из самого класса и из его наследников.
4. `readonly` - свойство с модификатором `readonly` доступно только для чтения. Его значение может быть установлено только при создании экземпляра класса или в конструкторе. Далее его нельзя изменить.

[Вернуться к началу статьи](#typescript)

---

## Type Assertions

> Type Assertions в TypeScript - это механизм, который позволяет программисту явно указать тип данных, которым должна обладать переменная или выражение.

1. Первый — синтаксис с использованием угловых скобок (<>):

```typescript
const header = <HTMLElement>document.getElementById('header')
```

2. Вторая форма заключается в применении оператора `as`, после которого указывается тип, к которому надо выполнить преобразование.

```typescript
const header = document.getElementById('header') as HTMLElement
```

### ВАЖНО!!!

> Чтобы избежать ошибок, связанных с использованием Type Assertions, следует стараться избегать их использования. Лучше явно объявлять тип данных переменной или выражения, когда это возможно, и использовать возможности TypeScript для определения типа данных переменных на этапе компиляции. Если же все-таки необходимо использовать Type Assertions, следует удостовериться в правильности их применения и правильности указания типа данных.

### ВАЖНО!!! ПОСТФИКС `!`

> Постфикс `!` в TypeScript используется для указания компилятору TypeScript, что переменная имеет значение, когда это не является очевидным.
> Например, если мы определим переменную `name: string | undefined`, компилятор TypeScript будет требовать от нас проверки, что name не является `undefined` перед использованием этой переменной. В таком случае мы можем использовать постфикс `!`, чтобы показать, что мы уверены, что переменная имеет значение:

```typescript
if (name !== undefined) {
	console.log(name.toLocaleLowerCase())
}
console.log(name!.toLocaleLowerCase())
```

[Вернуться к началу статьи](#typescript)

---

## Interface in TypeScript

> Интерфейсы TypeScript - это механизм, который позволяет определять контракты, которые должны быть реализованы классами или объектами. Они используются для описания формы объекта или класса и указания наличия конкретных методов или свойств. Интерфейсы предоставляют основу для реализации полиморфизма в TypeScript, который позволяет программисту работать с разными классами, реализующими одинаковые интерфейсы, используя единый API.

> В TypeScript `?` после имени свойства интерфейса, аргумента функции или переменной означает, что это значение не обязательно и может быть `undefined`.

- `x?: number и x: number | undefined` - это два способа определения необязательного параметра со значением по умолчанию в TypeScript.

- `x?: number` означает, что параметр `x` не обязателен и может быть опущен при вызове функции. Если параметр `x` был опущен, то его значение будет равно `undefined`.

- `x: number | undefined` означает, что параметр `x` может иметь значение типа `number` или может быть равен `undefined`.

> В TypeScript интерфейсы могут наследоваться друг от друга с помощью ключевого слова extends. Это позволяет создавать иерархию интерфейсов и наследовать свойства и методы от родительских интерфейсов.

```typescript
interface Animal {
	name: string
	eat(food: string): void
}

interface Dog extends Animal {
	breed: string
	bark(): void
}

interface Cat extends Animal {
	breed: string
	meow(): void
}
```

> Когда интерфейс наследует от класса, он также получает все свойства и методы класса, но это может наложить некоторые ограничения.

> Например, если класс определяет свойства как `private` или `protected`, то эти свойства недоступны для интерфейса, который от него наследуется. Кроме того, если класс содержит реализацию методов, то интерфейс не может наследовать от таких методов.

> Поэтому в большинстве случаев наследование интерфейсов не должно происходить от классов с реализацией. Чтобы избежать этой проблемы, рекомендуется использовать абстрактные классы вместо обычных классов с реализацией. Абстрактные классы могут содержать общие методы и свойства, а также определять абстрактные методы без их реализации, которые могут быть реализованы в дочерних классах. В этом случае наследование интерфейсов от абстрактных классов не вызовет таких проблем.

### ВАЖНО!!!

> В TypeScript класс может одновременно реализовывать набор интерфейсов и наследоваться от другого класса с помощью ключевых слов `implements` и `extends`.

- С помощью `implements` классы могут реализовывать набор интерфейсов, перечисленных через запятую. Интерфейсы описывают требования к структуре и поведению класса, что упрощает проверку типов данных и возможное переиспользование кода.

```typescript
interface Animal {
	name: string
	eat(food: string): void
}

interface CanFly {
	fly(speed: number): void
}

class Bird implements Animal, CanFly {
	constructor(public name: string) {}

	eat(food: string) {
		console.log(`${this.name} is eating ${food}.`)
	}

	fly(speed: number) {
		console.log(`${this.name} is flying at ${speed} km/h.`)
	}
}

const sparrow = new Bird('Sparrow')
sparrow.eat('seeds')
sparrow.fly(20) // Sparrow is flying at 20 km/h.
```

- С помощью `extends` классы могут наследоваться от других классов и расширять свои свойства и методы.

```typescript
interface Animal {
	name: string
	eat(food: string): void
}

class Cat implements Animal {
	constructor(public name: string) {}

	eat(food: string) {
		console.log(`${this.name} is eating ${food}.`)
	}
}

class Tiger extends Cat {
	constructor(public name: string) {
		super(name)
	}

	hunt(target: string) {
		console.log(`${this.name} is hunting ${target}.`)
	}
}

const tiger = new Tiger('Tiger')
tiger.eat('meat')
tiger.hunt('deer') // Tiger is hunting deer.
```

> - Обычный класс в TypeScript используется для создания объектов с определенными свойствами и методами, в то время как абстрактный класс может содержать методы без абстрактной реализации, которые наследуются дочерними классами. Абстрактный класс похож на обычный класс, но не может быть использован напрямую для создания объектов, только для наследования.
> - Интерфейсы в TypeScript определяют абстрактные типы данных. Они описывают набор методов и свойств, которые должны быть реализованы классом или объектом, но не определяют их реализацию. Интерфейсы могут быть реализованы несколькими классами или объектами без явного наследования.
> - **Основное отличие** между абстрактными классами и интерфейсами состоит в том, что абстрактный класс поддерживает реализацию методов, в то время как интерфейс не поддерживает. Обычный класс может наследовать только один класс, в то время как он может реализовывать несколько интерфейсов.

### ВАЖНО!!!

> Можно объявить тип метода интерфейса так, чтобы он возвращал контекст вызова своего метода в TypeScript, используя тип `this` для указания типа, который представляет экземпляр объекта, на котором был вызван метод.

```typescript
interface ISomething {
	getThis(): this
}

class Something implements ISomething {
	public getThis() {
		return this
	}
}
```

> Таким образом, метод `getThis` возвращает тип `this`, который представляет экземпляр объекта, на котором был вызван метод. Класс `Something` реализует этот интерфейс, и метод `getThis` возвращает объект класса `Something`.

[Вернуться к началу статьи](#typescript)

---

## Type Aliases in TypeScript

> Type Aliases в TypeScript - это механизм, который позволяет задать собственное имя для любого типа данных, в том числе для других пользовательских типов данных, таких как типы интерфейсов, классов, примитивные типы данных и прочее. Они используются для создания более читаемого, лаконичного и понятного кода при работе с сложными типами данных.
> В отличие от интерфейсов, Type Aliases могут быть использованы не только для определения формы объектов, но и для определения более сложных типов данных, таких как объединение нескольких типов данных, наложение наследования, а также для определения типов переменных и параметров функций.

```typescript
type Point = {
	x: number
	y: number
}

type ThreeDimensionalPoint = Point & {
	z: number
}

type Color = 'red' | 'green' | 'blue'

type User = {
	name: string
	age: number
	email: string
}

type Nullable<T> = T | null
```

[Вернуться к началу статьи](#typescript)

---

## Hybrid Types

> Hybrid Types (смешанные типы) в TypeScript - это типы, которые сочетают в себе два или более типа данных, таких как объекты, функции, классы или интерфейсы, в одном объявлении. Они позволяют моделировать объекты, которые имеют разные свойства или методы в разных контекстах.

> Hybrid Types могут быть использованы для создания объектов с разными свойствами и методами в зависимости от контекста. Например, такой объект может иметь методы, которые используются только в одном контексте, и свойства, которые используются только в другом контексте.

```typescript
interface Counter {
	(start: number): string
	increment(): void
	reset(): void
}

function getCounter(): Counter {
	let counter = function (start: number) {} as Counter
	counter.increment = function () {}
	counter.reset = function () {}
	return counter
}

let c = getCounter()
c(10)
c.increment()
c.reset()
```

> В этом примере, объект Counter представляет собой функцию, которая может принимать число в качестве аргумента и возвращать строку, а также имеет методы increment и reset, которые не принимают аргументов и не возвращают значения.

[Вернуться к началу статьи](#typescript)

---

## Index Types

> Index Types (индексные типы) - это функциональность в TypeScript, которая позволяет создавать объекты, свойства которых могут быть определены и доступны по именам свойств во время выполнения.

> Index Types позволяют создавать объекты с динамическими свойствами, которые могут определяться только во время выполнения программы.

```typescript
// В этом примере, интерфейс Dictionary определяет объект,
// содержащий набор ключей и соответствующих значений любого типа T.
// Ключи могут быть любой строкой, а значением может быть объект любого типа T
interface Dictionary<T> {
	[key: string]: T
}
```

> Index Types могут быть использованы для создания обобщенных типов, которые могут работать с любыми объектами, содержащими свойства с заданными типами. Например, это может быть полезно для работы с объектами, возвращаемыми из API, которые имеют различные свойства в зависимости от запроса.

```typescript
type Employee = {
	name: string
	age: number
	salary: number
}

type EmployeeInfo<T> = {
	[P in keyof T]: T[P]
}

const employee: Employee = {
	name: 'John Doe',
	age: 45,
	salary: 150000,
}

const employeeInfo: EmployeeInfo<Employee> = {
	name: employee.name,
	age: employee.age,
	salary: employee.salary,
}
```

> Оператор `keyof` в TypeScript используется для создания типа, который представляет собой объединение имен свойств объекта.

> Оператор keyof позволяет получить тип, который содержит имена всех свойств объекта. Таким образом, мы можем использовать этот тип для создания других типов, которые зависят от имен свойств объекта.

```typescript
// Здесь мы определили интерфейс Person, который имеет три свойства: name, age и address.
// Затем мы определили тип PersonProps, который использует оператор keyof, чтобы получить тип,
// который содержит имена всех свойств объекта Person.
interface Person {
	name: string
	age: number
	address: string
}

type PersonProps = keyof Person

// Тип PersonProps равен "name" | "age" | "address"

const key: PersonProps = 'name' // Допустимое значение
const key2: PersonProps = 'height' // Ошибка типа
```

Мы можем использовать этот тип, например, для определения типа, который принимает имя свойства объекта в качестве параметра:

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K) {
	return obj[key]
}

const person: Person = { name: 'John', age: 30, address: '123 Main Street' }
const name = getProperty(person, 'name') // тип name: string
const age = getProperty(person, 'age') // тип age: number
const height = getProperty(person, 'height') // Ошибка типа, свойство height не существует в объекте
```

> Здесь мы определяем функцию `getProperty`, которая принимает два параметра: объект `T` и ключ `K`, который должен быть именем одного из свойств этого объекта. Тип `K` ограничен ключами `T`, целевыми типами свойств объекта `T`.

> Затем мы вызываем функцию `getProperty` с объектом Person и именем свойства `name`. Вызов `getProperty` возвращает значение свойства name из объекта `Person` тип гарантированной безопасности.

[Вернуться к началу статьи](#typescript)

---

## Mapped Types

> Mapped Types (отображаемые типы) - это возможность TypeScript создавать новые типы данных на основе существующих типов данных.

> Они позволяют создавать новый тип данных, который содержит только определенные свойства из существующих типов, изменять их модификаторы (readonly, optional), добавлять новые свойства и определять, как эти свойства должны быть изменены.

> Ключевым словом для определения Mapped Types является `keyof`, которое извлекает ключи из указанного типа, затем используется оператор `in` для перебора этих ключей и создания нового типа.

```typescript
// Создание нового типа данных на основе существующих свойств
type PersonName = 'John' | 'Amy' | 'Bob'
type PersonMap = { [key in PersonName]: boolean }

// Добавление модификатора readonly к существующим свойствам
type ReadonlyProps<T> = {
	readonly [P in keyof T]: T[P]
}

// Создание нового типа данных на основе существующего типа, заменяя определенные свойства на новые значения
type ReplaceProps<T, K extends keyof T, V> = {
	[P in keyof T]: P extends K ? V : T[P]
}
```

> Чтобы создать собственный Mapped Type, вы должны использовать ключевое слово MappedType и задать шаблон, который описывает, как вы хотите изменить тип данных.

```typescript
type MyMappedType<T> = {
	[P in keyof T]?: T[P] | null
}
```

[Вернуться к началу статьи](#typescript)

---

## Generic types

> Generics - это мощный инструмент в TypeScript, который позволяет создавать обобщенные (универсальные) типы данных. Обобщенные типы позволяют создавать функции, классы и интерфейсы, которые могут работать с различными типами данных, не зная тип заранее.

> В TypeScript обобщенные типы обозначаются с помощью символов `<` и `>`.

```typescript
function getFirst<T>(arr: T[]): T | undefined {
	return arr.length > 0 ? arr[0] : undefined
}

// Здесь <T> - это параметр типа, который говорит функции,
// что мы будем передавать массив любого типа в качестве параметра, и передает его возвращаемому значению.
const arr1 = [1, 2, 3]
const arr2 = ['a', 'b', 'c']
const num = getFirst(arr1) // typeof num === 'number'
const str = getFirst(arr2) // typeof str === 'string'

function identity<T>(value: T): T {
	return value
}

identity<number>(1) // 1
identity<string>('1') // "1"

function identityFree<T, U>(value: T, messsage: U): T {
	console.log(message)
	return value
}

identityFree<number, string>(26, 'hello') // return 26
```

> TypeScript поставляется с несколькими встроенными универсальными типами (generic types), которые могут использоваться в различных контекстах.

1. `Array<T>` : это универсальный тип для массивов. Он может быть использован для создания массива значений любого типа T.

```typescript
const numbers: Array<number> = [1, 2, 3, 4]
const strings: Array<string> = ['hello', 'world']
```

2. `Promise<T>` : это универсальный тип обещаний, который представляет асинхронную операцию, которая должна выполниться в будущем и вернуть значение типа T.

```typescript
const promise: Promise<string> = new Promise((resolve, reject) => {
	setTimeout(() => {
		resolve('Hello, world!')
	}, 1000)
})

promise.then(result => console.log(result)) // "Hello, world!"
```

3. `ReadonlyArray<T>` : это универсальный тип для массивов с только для чтения свойствами. Он предоставляет те же самые методы, что и обычные массивы, но теперь методы изменения массива (например, push, pop) могут вызвать ошибку во время компиляции.

```typescript
const readonlyNumbers: ReadonlyArray<number> = [1, 2, 3, 4]
```

4. `Partial<T>` : это универсальный тип, который делает все свойства типа T необязательными.

```typescript
interface Person {
	name: string
	age: number
	location: string
}

type PartialPerson = Partial<Person>

const person: PartialPerson = { name: 'John' }
```

5. `Record<K, T>`: это универсальный тип, который представляет словарь (ассоциативный массив), где ключевое значение имеет тип K, а значение элемента имеет тип T.

```typescript
type PhoneNumbers = Record<string, number>

const phoneNumbers: PhoneNumbers = {
	John: 1234567890,
	Jane: 2345678901,
	Bob: 3456789012,
}
```

- Ограничение возможных значений переменной типа:

```typescript
type Color = 'red' | 'blue' | 'green'
let myColor: Color

myColor = 'red' // OK
myColor = 'yellow' // Ошибка компиляции
```

> В TypeScript можно ограничить возможные значения переменной типа значениями другой переменной типа, используя ключевое слово `extends`. Для этого нужно создать переменную типа и использовать ее имя в качестве условия для ограничения типа другой переменной.

- Ограничить возможные значения типа переменной `B` значениями типа переменной `A`:

```typescript
type A = 'foo' | 'bar' | 'baz'
type B<T extends A> = T

const value1: B<'foo'> = 'foo' // OK
const value2: B<'qux'> = 'qux' // Ошибка компиляции
```

> В TypeScript можно указать значение по умолчанию для переменных типа. Это делается с помощью оператора `=` после объявления типа переменной.

```typescript
type MyType<T = string> = {
	prop: T
}

const a: MyType = { prop: 'hello' } // a имеет тип MyType<string>
const b: MyType<number> = { prop: 10 } // b имеет тип MyType<number>
const c: MyType<boolean> = { prop: true } // c имеет тип MyType<boolean>
```

> Если при вызове функции явно передан дженерик аргумент, то TypeScript использует этот аргумент в качестве типа для соответствующего места в функции.

```typescript
function identity<T>(arg: T): T {
	return arg
}

let myIdentity = identity<number>(42)
```

> Если дженерик аргумент не передан, но используется для типизации аргумента функции, то TypeScript попытается вывести тип дженерик аргумента на основе типа переданного аргумента.

```typescript
function logLength<T>(arg: T[]): T[] {
	console.log(arg.length)
	return arg
}

let arr = logLength([1, 2, 3])
// Так как [1, 2, 3] является массивом типа number[], TypeScript выводит, что T равно number, и поэтому тип возвращаемого значения также будет number[].
```

> Если дженерик аргумент не передан, но используется для типизации возвращаемого функцией значения, TypeScript попытается вывести тип дженерик аргумента на основе контекста вызова функции.

```typescript
function identity<T>(arg: T): T {
	return arg
}

let myIdentity: <T>(arg: T) => T = identity
// Здесь мы определяем переменную myIdentity с типом функции, которую можно использовать для вызова identity.
// Мы не явно указываем тип дженерик аргумента, поэтому TypeScript попытается вывести его тип.

// Так как тип переменной myIdentity ожидает, что функция принимает и возвращает один и тот же тип, TypeScript выводит, что тип T должен быть тривиально выведен как any.
// Это означает, что функция identity будет иметь тип any => any, что может быть опасно в качестве типа функции.
```

[Вернуться к началу статьи](#typescript)

---

## Union and intersection type

> Union и intersection типы - это возможности TypeScript для объединения типов и пересечения типов, соответственно.

> Union тип объединяет два или более типа в единый тип. Это означает, что значение может иметь один из нескольких возможных типов. Оператором объединения в TypeScript является `|` (вертикальная черта) (или).

Вот пример использования Union типа:

```typescript
let value: string | number
value = 'hello' // OK
value = 42 // OK
value = true // Ошибка компиляции
```

> Intersection тип позволяет создавать новые типы, которые являются объединением нескольких других типов. Это означает, что новый тип будет содержать все свойства и методы из каждого из исходных типов. Оператором пересечения в TypeScript является `&` (амперсанд) (и).

Вот пример использования Intersection типа:

```typescript
interface Debuggable {
	debug(): string
}

interface Loggable {
	log(): void
}

function mixin<T extends Debuggable & Loggable>(obj: T): void {
	console.log(obj.debug())
	obj.log()
}

let myObj = {
	debug() {
		return 'Debug data'
	},
	log() {
		console.log('Logging data')
	},
}

mixin(myObj)
```

[Вернуться к началу статьи](#typescript)

---

## Type Guards

> Type Guards - это механизм TypeScript, который позволяет проверять тип переменной и использовать эту информацию для определения выполнения определенных операций или методов.

> Type Guards будут полезны, когда вы имеете дело со значениями, которые могут иметь различные типы в зависимости от контекста. Это может быть полезно, например, когда вы работаете со значениями, полученными из пользовательского ввода, или когда вы обрабатываете значения, которые могут быть одного из нескольких возможных типов.

Type Guards могут использоваться для проверки различных типов, таких как классы, интерфейсы, перечисления и другие типы данных, и включают в себя следующие методы:

1. `typeof` оператор

```typescript
if (typeof num === 'number') {
	console.log('num is a number')
}
```

2. `instanceof` оператор

```typescript
if (user instanceof AdminUser) {
	console.log('user is an AdminUser')
}
```

3. Проверка наличия свойства

```typescript
if ('name' in obj) {
	console.log('obj has a name property')
}
```

4. Проверка на значение `null` или `undefined`

```typescript
if (value !== null && value !== undefined) {
	console.log('value is not null or undefined')
}
```

5. Сравнение `==/===`. Операторы сравнения могут использоваться для проверки типов переменных. Например, чтобы проверить, является ли переменная числом:

```typescript
function isNumber(x: any): x is number {
	return typeof x === 'number'
}

let value: any = 42

if (isNumber(value)) {
	console.log('value is a number')
} else {
	console.log('value is not a number')
}
```

6. Отрицание `!`. Если переменная типа `T | null | undefined`, мы можем использовать оператор отрицания, чтобы исключить значения `null` и `undefined`:

```typescript
function doSomething(x: string | null | undefined) {
	if (!x) {
		console.log('x is null or undefined')
	} else {
		console.log('x is a string')
	}
}
```

7. Двойное отрицание `!!`:

```typescript
function isDefined<T>(x: T | null | undefined): x is T {
	return !!x
}

let value: string | null = null

if (isDefined(value)) {
	console.log('value is a string')
} else {
	console.log('value is null or undefined')
}
// Функция isDefined использует двойное отрицание (!!) для преобразования переменной x в булевое значение.
// Если переменная имеет значение null или undefined, то двойное отрицание вернет false.
// В противном случае, переменная будет рассматриваться как истинное (true) значение.
```

### ВАЖНО!!!

> При наследовании от Error и создании собственных ошибок, instanceof может вернуть некорректный результат во время проверки экземпляров нашей собственной ошибки. Это происходит из-за того, что ошибка, созданная пользователем, наследует свойства и методы объекта Error, но не является экземпляром самого Error.

> В результате, если мы проверяем, является ли наш экземпляр ошибки объектом Error, instanceof может вернуть false. Это может быть нарушением ожидаемого поведения, если мы полагаемся на instanceof для правильного определения типа ошибки в нашем коде.

> Чтобы решить эту проблему и гарантировать правильную проверку нашей собственной ошибки, мы можем использовать следующий шаблон для наследования собственных ошибок от Error:

```typescript
class MyError extends Error {
	constructor(message?: string) {
		super(message)
		Object.setPrototypeOf(this, MyError.prototype)
	}
}

let err = new MyError()
console.log(err instanceof Error) //вернет true
console.log(err instanceof MyError) //вернет true
```

Вместо того, чтобы использовать this.prototype = new Error(), мы можем использовать Object.setPrototypeOf(this, MyError.prototype). Это обновляет прототип для this, чтобы он ссылался на прототип MyError вместо Error.

Таким образом, мы можем гарантировать, что наши собственные ошибки будут экземплярами Error и можно использовать instanceof для проверки наличия ошибок верно.

### ВАЖНО!!!

> Можно объявить свой Type Guard, чтобы использовать его для проверки типов переменных. Типически, Type Guard используется вместе с оператором `if` для определения, соответствует ли значение определенному типу.

```typescript
function isNumber(value: any): value is number {
	return typeof value === 'number'
}
```

> В этом примере мы создали функцию isNumber. Эта функция принимает параметр value, проверяет, является ли его тип числом (typeof value === "number") и возвращает true, если это так.

> Но что это за выражение value is number? Оно сообщает TypeScript, что тип value на самом деле является number, и если функция isNumber возвращает true, то TypeScript будет считать, что value имеет тип number.

```typescript
// Теперь мы можем использовать наш Type Guard для проверки типа значения:
let value: any = 42

if (isNumber(value)) {
	console.log('value is a number')
} else {
	console.log('value is not a number')
}
```

[Вернуться к началу статьи](#typescript)

---

## Assertion Functions

> Assertion Functions - это функции, которые используются для явного утверждения в коде TypeScript об информации, которая не может быть выведена компилятором TypeScript.

> Assertion Functions объявляются как функции, которые возвращают тип `asserts x is T`, где `x` - это аргумент функции, а `T` - это тип, который мы утверждаем, что `x` имеет.

```typescript
function findElement<T>(arr: T[], func: (el: T) => boolean) {
	for (const el of arr) {
		if (func(el)) {
			return el
		}
	}
}
```

> Компилятор TypeScript не может определить тип элемента массива, который мы находим с помощью функции `func`. Но мы можем использовать Assertion Function, чтобы уточнить тип:

```typescript
function findElement<T, U extends T>(arr: T[], func: (el: T) => el is U): U {
	for (const el of arr) {
		if (func(el)) {
			return el
		}
	}
	throw new Error('element not found')
}
// В этом примере мы добавили Assertion Function, которая уточняет тип элемента массива до U.
// Функция findElement теперь принимает функцию func, которая возвращает true, если элемент массива является типом U.
```

[Вернуться к началу статьи](#typescript)

---

## Decorators in TypeScript

> Декораторы - это экспериментальный языковой элемент(функция), добавленный в ECMAScript 2016 и поддерживаемый в TypeScript, который позволяет добавлять метаданные к классам и их членам (методам, свойствам, параметрам и т.д.).

```typescript
@decorator
class MyClass {
	@decorator
	myMethod() {}
}
```

> Чтобы применить декоратор ко всем экземплярам класса, нужно использовать декоратор для прототипа класса:

```typescript
function myClassDecorator<T extends { new (...args: any[]): {} }>(constructor: T) {
	return class extends constructor {
		newProperty = 'new property'
		hello = 'override'
	}
}

@myClassDecorator
class MyClass {
	hello: string
	constructor(m: string) {
		this.hello = m
	}
}

console.log(new MyClass('world').newProperty) // "new property"
```

[Вернуться к началу статьи](#typescript)

---

## Function overload

> Перегрузка функции в TypeScript - это возможность определить несколько сигнатур одной функции с разными типами параметров или разным числом параметров. TypeScript использует перегрузку функций для обеспечения статической типизации и контроля типов в процессе компиляции.

- Путем определения нескольких сигнатур и соответствующей реализации:

```typescript
function concatenate(x: string, y: string): string
function concatenate(x: number, y: number): number
function concatenate(x: any, y: any): any {
	return x + y
}
```

- С использованием типов-объединений:

```typescript
function displayType(arg: string | number) {
	if (typeof arg === 'string') {
		console.log('Это строка: ' + arg)
	} else if (typeof arg === 'number') {
		console.log('Это число: ' + arg)
	}
}
```

- С использованием интерфейсов:

```typescript
interface Car {
	make: string
	model: string
}

interface Bike {
	brand: string
	type: string
}

function displayVehicle(vehicle: Car | Bike) {
	if ('make' in vehicle) {
		console.log(`Это машина ${vehicle.make} ${vehicle.model}`)
	} else {
		console.log(`Это велосипед ${vehicle.brand} типа ${vehicle.type}`)
	}
}
```

[Вернуться к началу статьи](#typescript)

---

## Typing class constructor

> Для типизации конструктора класса в TypeScript вы можете воспользоваться типом класса. Тип класса представляет собой тип, описывающий структуру экземпляров класса, включая конструктор класса и его методы.

```typescript
class Person {
	name: string

	constructor(name: string) {
		this.name = name
	}
}

let person: Person = new Person('Alice')
console.log(person.name) // Выведет "Alice"
```

> Относительно типизации перегрузки конструктора для класса, в TypeScript нельзя явно определить перегрузку конструктора как для обычных функций. Однако, определение различных вариантов конструктора можно сделать, используя параметры по умолчанию или опциональные параметры.

```typescript
class Car {
	make: string
	model: string

	constructor(make: string, model?: string) {
		this.make = make
		this.model = model || 'Unknown'
	}
}

let car1: Car = new Car('Toyota')
let car2: Car = new Car('Ford', 'Focus')

console.log(car1.make, car1.model) // Выведет "Toyota Unknown"
console.log(car2.make, car2.model) // Выведет "Ford Focus"
```

[Вернуться к началу статьи](#typescript)

---

## Const assertion

> Const assertion (утверждение const) — это специальная функциональность в TypeScript, которая позволяет явно указать компилятору, что переменная должна быть рассмотрена как неизменяемая (const) при выводе типа, независимо от того, какое значение у неё есть в данный момент.

- Пример использования const assertion:

```typescript
let x = 'hello' as const
// x теперь имеет тип "hello", а не string
```

> Const assertion полезно в ситуациях, когда вы уверены, что значение переменной не должно изменяться, и хотите, чтобы TypeScript обеспечил эту неизменяемость.

Однако у const assertion есть свои ограничения:

1. Когда применяется к объекту или массиву, const assertion "замораживает" только первый уровень свойств, но не глубоко.

```typescript
const obj = { a: 1, b: { c: 2 } } as const
obj.a = 5 // Ошибка: Не удается присвоить новое значение
obj.b.c = 10 // Работает, так как глубокие свойства не являются неизменяемыми
```

2. Не работает с переменными, которые уже имеют тип, несовместимый с const.

```typescript
let y: string = 'world'
let z = y as const // Ошибка: Нельзя использовать const assertion с переменными других типов
```

[Вернуться к началу статьи](#typescript)

---

## Assigning types

1. `Partial<T>` - Создает тип, состоящий из всех опциональных свойств из типа T.

```typescript
interface User {
	name: string
	age?: number
}

const partialUser: Partial<User> = { name: 'Alice' }
```

2. `Readonly<T>` - Создает тип, в котором все свойства только для чтения.

```typescript
interface Point {
	x: number
	y: number
}

const readOnlyPoint: Readonly<Point> = { x: 1, y: 2 }
readOnlyPoint.x = 5 // Ошибка: Нельзя изменять свойства только для чтения
```

3. `Required<T>` - Создает тип, в котором все свойства становятся обязательными.

```typescript
interface Props {
	name?: string
	age?: number
}

const requiredProps: Required<Props> = { name: 'Bob', age: 30 }
```

4. `Record<T, U>` - Создает тип, представляющий объект, в котором ключи имеют тип T, а значения имеют тип U.

```typescript
const users: Record<string, { age: number }> = {
	Alice: { age: 25 },
	Bob: { age: 30 },
}
```

5. `Pick<T,U>` - Создает тип, содержащий только выбранные свойства из типа T.

```typescript
interface User {
	name: string
	age: number
	city: string
}

const userSubset: Pick<User, 'name' | 'city'> = {
	name: 'Alice',
	city: 'New York',
}
```

6. `Omit<T,K>` - Создает тип, исключая выбранные свойства из типа T.

```typescript
interface User {
	name: string
	age: number
	city: string
}

const userWithoutAge: Omit<User, 'age'> = {
	name: 'Alice',
	city: 'New York',
}
```

7. `Exclude<T, U>` - Создает тип, который исключает из типа T все элементы, которые также присутствуют в типе U. .

```typescript
type Colors = 'red' | 'blue' | 'green' | 'yellow'
type PrimaryColors = Exclude<Colors, 'green' | 'yellow'>
```

8. `Extract<T, U>` - Создает тип, который выбирает из типа T только элементы, которые также присутствуют в типе U.

```typescript
type Colors = 'red' | 'blue' | 'green' | 'yellow'
type PrimaryColors = Extract<Colors, 'red' | 'blue'>
```

9. `NonNullable<T>` - Создает тип, который исключает из типа T значение null и undefined.

```typescript
type NonNullString = NonNullable<string | null | undefined> // будет только string
```

10. `ReturnType<T>` - Получает тип возвращаемого значения из функции.

```typescript
function greet(): string {
	return 'Hello!'
}

type Greeting = ReturnType<typeof greet> // будет string
```

11. `Parameters<T>` - Получает тип параметров функции.

```typescript
function sum(a: number, b: number): number {
	return a + b
}

type SumParams = Parameters<typeof sum> // будет [number, number]
```

12. `InstanceType<T>` - Получает тип экземпляра конструктора класса.

```typescript
class Car {
	brand: string
	constructor(brand: string) {
		this.brand = brand
	}
}

type CarInstance = InstanceType<typeof Car> // будет Car
```

13. `ThisType<T>` - Это контекстный тип, который позволяет указать тип для `this` внутри объекта или функции.

```typescript
interface User {
	name: string
	sayHello(this: User): void
}

const user: User = {
	name: 'Alice',
	sayHello() {
		console.log(`Hello, ${this.name}!`)
	},
}
```

[Вернуться к началу статьи](#typescript)

---

## Conditional Types

> Conditional Types (условные типы) в TypeScript предназначены для создания типов, которые зависят от условий. Они позволяют определять типы на основе проверки какого-либо условия.

> С Conditional Types вы можете создавать типы, которые изменяются в зависимости от проверки типа входных параметров или других типов. Это полезно при условной проверке типов во время компиляции кода.

```typescript
type CheckUser<T> = T extends string ? 'Is a string' : 'Not a string'

type StringType = CheckUser<string> // "Is a string"
type NumberType = CheckUser<number> // "Not a string"
```

### Проявление дистрибутивности Conditional Types.

> В TypeScript дистрибутивность в Conditional Types проявляется в том, что когда Conditional Type определен через обобщенный тип (generic type), он автоматически применяется к каждому элементу типа, который является объединением (union) или пересечением (intersection).
> Для понимания концепции дистрибутивности в Conditional Types давайте рассмотрим пример:

```typescript
type MyType<T> = T extends any ? T[] : never

type StringArray = MyType<string> // string[]
type NumberArray = MyType<number> // number[]
type StringOrNumberArray = MyType<string | number> // (string | number)[]
type StringAndNumberArray = MyType<string & number> // never
```

- StringArray будет `string[]`, так как `MyType<string>` будет интерпретирован как массив строк.
- NumberArray будет `number[]`, так как `MyType<number>` будет интерпретирован как массив чисел.
- StringOrNumberArray будет `(string | number)[]`, так как `MyType<string | number>` будет интерпретирован как массив строк и чисел.
- StringAndNumberArray будет never, так как `MyType<string & number>` не имеет смысла и возвращает never.

> Таким образом, дистрибутивность в Conditional Types позволяет автоматически распространять условные типы на каждый элемент объединения или пересечения типов. Это делает их более мощными и удобными в использовании.

### Удаление составного типа из union type с помощью Conditional Types.

> Для удаления определенного типа из объединения типов можно использовать Conditional Types в TypeScript. Давайте рассмотрим пример, где мы удалим строковый тип из объединения типов с помощью Conditional Types:

```typescript
type ExcludeString<T> = T extends string ? never : T

type OriginalUnion = string | number | boolean

type NewUnion = ExcludeString<OriginalUnion> // number | boolean
```

> В этом примере мы создали тип `ExcludeString<T>`, который проверяет, является ли тип T строковым. Если T является строкой, то он возвращает never, иначе возвращает сам T.

> Затем мы определили начальное объединение типов `OriginalUnion`, которое содержит string, number и boolean.

> С помощью `ExcludeString<OriginalUnion>` мы создали новое объединение типов NewUnion, из которого исключен тип string. Таким образом, NewUnion будет равен number | boolean, и тип string будет удален из объединения типов.

> Это простой способ удаления определенного типа из объединения типов с использованием Conditional Types в TypeScript.

### Использование Conditional Types совместно с Mapped Types.

> B TypeScript вы можете использовать Conditional Types в сочетании с Mapped Types для более сложных и мощных операций с типами. Путем объединения Conditional Types и Mapped Types вы можете создавать более гибкие и сложные типы.

```typescript
type KeysOfType<T, U> = {
	[K in keyof T]: T[K] extends U ? K : never
}

interface Person {
	name: string
	age: number
	city: string
}

type StringKeysOfPerson = KeysOfType<Person, string>

// StringKeysOfPerson: {
//   name: "name";
//   city: "city";
// }
```

> В этом примере мы определили тип KeysOfType<T, U>, который отображает свойства объекта типа T, которые имеют значение типа U.

> Затем мы создаем интерфейс Person, имеющий свойства name, age и city.

> С помощью `KeysOfType<Person, string>` мы создаем новый тип StringKeysOfPerson, который содержит только те свойства объекта Person, значения которых являются строками. В результате получаем { name: "name", city: "city" }.

> Таким образом, использование Conditional Types совместно с Mapped Types в TypeScript может быть очень полезным для создания сложных манипуляций с типами.

### Для чего нужен infer? Допускается ли использовать infer для типов не являющихся Conditional Types?

> Ключевое слово `infer`в TypeScript используется в Conditional Types для вывода типов из других типов. Оно позволяет присваивать типы из одной части типа другой части типа.

> `infer` удобно использовать, когда вы хотите извлечь и сохранить тип из другого типа на определенном месте в общей структуре типа.

```typescript
type ReturnType<T> = T extends (...args: any[]) => infer R ? R : never

function foo(): number {
	return 1
}

type FooReturnType = ReturnType<typeof foo> // FooReturnType будет типом `number`
```

> Однако вне Conditional Types, infer не используется и не имеет смысла. Оно предназначено специально для вывода типов в условных типах и не применяется в других контекстах.

> Таким образом, использование infer вне Conditional Types не допускается в TypeScript. Однако внутри Conditional Types оно может быть очень полезным для работы с типами

### Возможно ли в TypeScript объявление рекурсивных type Aliases?

> Да, в TypeScript можно объявлять рекурсивные псевдонимы типов (recursive type aliases), которые ссылются на себя самих. Это может быть полезно при работе с структурами данных, которые могут быть рекурсивными, например, для работы с деревьями или списками.

- Пример объявления рекурсивного псевдонима типа в TypeScript:

```typescript
type TreeNode<T> = {
	value: T
	children: TreeNode<T>[]
}

const tree: TreeNode<number> = {
	value: 1,
	children: [
		{
			value: 2,
			children: [
				{
					value: 3,
					children: [],
				},
			],
		},
		{
			value: 4,
			children: [],
		},
	],
}
```

> В этом примере `TreeNode<T>` представляет собой рекурсивный тип, который описывает структуру узла дерева с значением типа T и массивом дочерних узлов того же типа `TreeNode<T>`. Это позволяет создавать деревья произвольной глубины.

> Таким образом, TypeScript поддерживает объявление рекурсивных псевдонимов типов, что делает его более мощным инструментом для работы с различными структурами данных.

[Вернуться к началу статьи](#typescript)

---

## Type soundness and Type safety

> Между `type soundness` и `type safety` есть разница, хотя они оба связаны с типизацией в программировании.

- `Type safety (типобезопасность)`: Это свойство языка программирования, которое гарантирует, что программы не смогут выполнять операции над данными, которые не соответствуют их типам. Например, если язык является типобезопасным, нельзя присвоить строку переменной, предназначенной для хранения числа, и далее выполнять арифметические операции, не удостоверившись, что это действительно число. Типобезопасность помогает предотвратить ошибки во время выполнения, обеспечивая корректность типов на уровне компиляции или интерпретации.

- `Type soundness (типовая состоятельность)`: Это более строгий концепт, относящийся к корректности системы типов в языке программирования. Язык считается типосостоятельным, если у всех типизированных выражений корректные типы, и если программа, написанная с учетом системы типов, никогда не выполнит неверную операцию в состоянии исполнения. Проще говоря, это означает, что если программа компилируется и проходит проверку типов, она не вызовет ошибок, связанных с типами, во время выполнения.

[Вернуться к началу статьи](#typescript)

---

## Structural typing

> Структурная типизация — это подход к типизации в языках программирования, который определяет совместимость типов на основе их структуры (или формы), а не на основе их имен или деклараций. Это означает, что два типа считаются совместимыми, если они имеют одинаковые поля (или методы) с одинаковыми типами, независимо от того, каким образом они были определены или названы.

```typescript
type PointA = { x: number; y: number }
type PointB = { x: number; y: number }
```

> `PointA` и `PointB` будут считаться совместимыми, даже если они объявлены отдельно, потому что у них одинаковая структура (оба имеют поля x и y с типом number).

> Структурная типизация контрастирует с номинальной типизацией, где типы совместимы только если они имеют одинаковое имя или явно указано, что они совместимы.

> Преимущество структурной типизации заключается в большей гибкости и возможности использования типов, не заботясь о их именах. Это позволяет создавать более универсальные и повторно используемые компоненты. Однако это также может привести к путанице, если разработчики не ясно понимают, какой именно тип используется.

> В TypeScript основным принципом типизации является структурная (или структурированная) типизация, где совместимость типов определяется на основе их структуры. Однако в некоторых случаях TypeScript применяет номинативную типизацию. Вот несколько примеров, когда это происходит:

1. `Классы и экземпляры`: Когда вы работаете с классами, TypeScript использует именования классов для определения совместимости типов. То есть, два класса с одинаковыми свойствами могут не считаться совместимыми, если они не являются экземплярами одного и того же класса.

2. `Type aliases и интерфейсы`: При использовании type aliases и интерфейсов, если вы создаете новый тип (alias) с помощью type или interface, то TypeScript будет рассматривать эти алиасы как разные типы, даже если они имеют одинаковую структуру.

3. `Параметры обобщений`: В обобщениях через типовые параметры TypeScript также может учитывать имена типов при определении совместимости.

4. `Наследование`: При наследовании классов, несмотря на то что дочерний класс может иметь структуру родительского класса, TypeScript все равно будет рассматривать их как разные типы.

> Создание интерфейсов и классов с одинаковой структурой не гарантирует совместимость в некоторых случаях в зависимости от контекста их использования. Это позволяет обеспечить больше контроля над тем, как типы используются и интегрируются в более крупные системы.

[Вернуться к началу статьи](#typescript)

---

## Declarations merging

> `Declaration merging` (слияние объявлений) — это особенность TypeScript, позволяющая объединять несколько объявлений одного и того же типа в одно. Это полезная функция, которая часто используется с интерфейсами и пространствами имен.

1. `Интерфейсы` : Если вы объявляете один и тот же интерфейс несколько раз, TypeScript автоматически объединит их свойства. Например:

```typescript
interface User {
	name: string
}

interface User {
	age: number
}

const user: User = {
	name: 'Alice',
	age: 30,
}
// Здесь интерфейс User имеет два свойства: name и age.
```

2. `Пространства имен`: Слияние также работает с пространствами имен. Вы можете объявить пространство имен несколько раз и добавить к нему новые свойства или функции:

```typescript
namespace MyNamespace {
	export const value = 42
}

namespace MyNamespace {
	export function doSomething() {
		console.log('Doing something!')
	}
}

MyNamespace.doSomething() // "Doing something!"
```

3. `Классы`: Хотя классы не поддерживают слияние объявлений в той же мере, что интерфейсы, вы все же можете добавлять методы к классу в расширенных определениях, если используете расширения:

```typescript
class Person {
	name: string
}

interface Person {
	age: number
}

const person: Person = {
	name: 'Bob',
	age: 25,
}
```

4. Методы

```typescript
interface Calculator {
	add(a: number, b: number): number
	add(a: string, b: string): string
}

const calc: Calculator = {
	add: (a: any, b: any) => {
		return a + b
	},
}

console.log(calc.add(1, 2)) // 3
console.log(calc.add('Hello, ', 'world!')) // Hello, world!

// В этом примере метод add перегружен для разных типов аргументов. TypeScript позволяет использовать один и тот же метод с разными сигнатурами.
```

> Таким образом, слияние объявлений позволяет разработчикам расширять и организовывать типы в TypeScript, создавая более модульные и читаемые структуры кода.

[Вернуться к началу статьи](#typescript)

---

## Compatibility

> `Compatibility` (совместимость) в TypeScript — это концепция, описывающая, как TypeScript оценивает, могут ли разные типы данных быть взаимозаменяемыми. Это особенно важно при работе с типами, интерфейсами и классами, поскольку позволяет избежать ошибок во время выполнения, обеспечивая, что объекты соответствуют ожидаемым структурам.

Основные принципы совместимости

- `Structural Typing` (структурная типизация):
  TypeScript использует структурную типизацию, что означает, что два типа считаются совместимыми, если их структуры (например, свойства и методы) совместимы между собой, а не только по их именам.

```typescript
interface Animal {
	name: string
}

interface Dog {
	name: string
	bark(): void
}

const myDog: Dog = {
	name: 'Rex',
	bark: () => console.log('Woof!'),
}

const myAnimal: Animal = myDog // Совместимо, потому что Dog имеет свойство name
```

- `Типы по умолчанию`:
  Если типы не совпадают, TypeScript может использовать правила совместимости по умолчанию. Например, null и undefined совместимы с любым типом, но это поведение может быть изменено с помощью компилятора.

- `Типы функций`:
  В TypeScript совместимость функций основана на совместимости параметров и возвращаемого значения. Чтобы функция считалась совместимой, количество и типы параметров должны совпадать:

```typescript
function add(a: number, b: number) {
	return a + b
}

const myAdd: (x: number, y: number) => number = add // Это совместимо

// Однако, если параметры имеют разные типы, это может привести к ошибкам.
```

- `Иерархия классов`:
  Если один класс наследует другой, экземпляры производного класса могут быть использованы как экземпляры базового класса. Это позволяет создавать более специфичные реализации:

```typescript
class Animal {
	move() {
		console.log('Moving')
	}
}

class Dog extends Animal {
	bark() {
		console.log('Woof!')
	}
}

const myDog: Animal = new Dog() // Совместимо из-за наследования
```

> TypeScript использует концепцию, называемую "субтипированием" `subtyping` для определения совместимости типов функций. Суть в том, что функция с меньшим количеством параметров совместима с функцией с большим количеством параметров, если дополнительные параметры не используются в процессе выполнения.

Почему это работает?

- Функции с меньшим количеством аргументов:

  - Функция, принимающая меньшее количество аргументов, может быть использована в контексте функции, принимающей большее количество. Это происходит потому, что вы можете вызывать функцию с меньшим количеством аргументов без необходимости передавать дополнительные параметры. То есть, если вашему контексту необходимо передать их, он просто не будет их использовать.

- Дополнительные параметры игнорируются:
  - В функции (b: number, s: string) => 0, если вы вызовете функцию с одним аргументом, TypeScript допускает игнорирование второго параметра. Таким образом, эта функция может быть вызвана нормально с одной переменной:

```typescript
const func: (b: number, s: string) => number = (a: number) => 0
func(5) // Работает корректно
```

- Ковариантность возвратного типа:
  - Важно отметить, что TypeScript требует, чтобы тип возвращаемого значения был совместимым, что обеспечивает определенную степень безопасности. Но в данном случае, если вы вернете один и тот же тип (или совместимый), это не станет проблемой.

```typescript
const funcOne: (a: number) => number = a => 0
const funcTwo: (b: number, s: string) => number = funcOne // Это допустимо

console.log(funcTwo(5, 'Hello')) // 0, игнорируем второй параметр
```

[Вернуться к началу статьи](#typescript)

---

## Type variance

> `Type variance` (вариантность типов) — это концепция в типизированных языках программирования, которая описывает, как типы могут изменяться или адаптироваться в зависимости от их подтипов. В TypeScript (и многих других языках) вариантность типов помогает определять, как функции и структуры данных могут работать с разными подтипами. Давайте разберем основные виды вариантности: инвариантность, ковариантность, контравариантность и бивариантность.

1. `Инвариантность (Invariance)`
   Инвариантный тип не совместим с его подтипами или надтипами. Это значит, что если у вас есть обобщенный тип с параметром типа, вы не можете заменить его подтипом.

```typescript
class Animal {}
class Dog extends Animal {}

let animal: Animal = new Animal()
// let dog: Animal = new Dog(); // Инвариантность: нельзя заменить
```

2. `Ковариантность (Covariance)`
   Ковариантные типы позволяют заменять типы на их подтипы. Это означает, что если у вас есть функция, которая возвращает некоторый тип, вы можете использовать её с его подтипом.

```typescript
class Animal {}
class Dog extends Animal {
	bark() {}
}

function getAnimal(): Animal {
	return new Dog() // Ковариантность: возвращается подтип
}
```

3. `Контравариантность (Contravariance)`
   Контравариантные типы позволяют использовать типы, которые являются надтипами. Это значит, что если функция принимает параметр, вы можете заменить его на более общий тип.

```typescript
class Animal {}
class Dog extends Animal {}

function handleAnimal(animal: Animal) {
	console.log(animal)
}

// Контравариантность: функция может принимать более общий тип
function handleDog(dog: Dog) {
	handleAnimal(dog) // Работает, так как Dog является Animal
}
```

4. `Бивариантность (Bivariance)`
   Бивариантные типы допускают и ковариантность, и контравариантность. Например, это можно встретить в массиве: вы можете как добавлять элементы, так и извлекать их независимо от того, являются ли они подтипами или надтипами.

Пример:

```typescript
let items: (Dog | Animal)[] = []
items.push(new Dog()) // Ковариантность: можно добавлять Dog
let animal: Animal = items[0] // Контравариантность: можно извлекать как Animal
```

### Если в функцию передать коллбек, который принимает другой коллбек, то параметры будут проявлять Covariance или Contravariance?

> В случае передачи коллбека в функцию, параметры будут проявлять контравариантность. Это связано с тем, что типы аргументов коллбека должны соответствовать сигнатуре, ожидаемой в функции, но также могут быть более общими.

1. Пример с контравариантностью

- Предположим, у нас есть базовый класс Animal и подкласс Dog. Мы также создадим функцию processAnimal, которая принимает коллбек в качестве параметра, а затем мы создадим коллбек, который будет обрабатывать подкласс Dog.

```typescript
class Animal {
	name: string
	constructor(name: string) {
		this.name = name
	}
}

class Dog extends Animal {
	bark() {
		console.log(`${this.name} says Woof!`)
	}
}

// Определяем функцию, которая принимает коллбек
function processAnimal(callback: (animal: Animal) => void) {
	const animal = new Animal('Generic Animal')
	callback(animal)
}

// Теперь мы создаем коллбек, который принимает Dog
function handleDog(dog: Dog) {
	dog.bark() // Делаем что-то специфичное для Dog
}

// Мы можем передать функцию, которая принимает Dog, как коллбек
// бивариантность происходит, здесь мы можем использовать более специфичный тип
processAnimal(handleDog) // Ошибка: Argument of type 'handleDog' is not assignable to parameter of type '(animal: Animal) => void'.
```

Почему это контравариантность?

> В данном случае функция processAnimal ожидает коллбек с параметром типа Animal, а мы пытаемся передать коллбек, который принимает параметры типа Dog. Таким образом, тип Dog является более специфичным, и это создаёт ошибку, так как мы не можем гарантировать, что handleDog будет работать с любым Animal.

> Однако, если мы изменим ситуацию и сделаем так, чтобы handleDog вызывал callback с типом Animal, то всё сработает:

```typescript
function handleAnimal(animal: Animal) {
	console.log(`Processing animal: ${animal.name}`)
}

// Теперь мы можем передать handleAnimal как коллбек
processAnimal(handleAnimal) // Это будет работать!
```

> В целом, при передаче коллбеков в функции параметры коллбеков проявляют контравариантность, что позволяет использовать более общий тип аргумента, чем тот, который ожидается в этом коллбеке. Однако более специфичные типы вызовут ошибку на этапе компиляции.

### Если бы объекты и классы TS были Invariant, то как бы это повлияло на type safety и на удобство разработки?

> Если бы объекты и классы в TypeScript были инвариантными, это означало бы, что нельзя было бы использовать ни более общий, ни более специфичный тип в месте, где ожидается определённый тип. Это могло бы значительно повлиять на безопасность типов и удобство разработки.

- Влияние на безопасность типов

  - `Ужесточение типов`: Инвариантность привела бы к тому, что разработчики не смогли бы использовать более специфичные типы, что снижало бы гибкость. Например, если у вас есть функция, принимающая параметр типа Animal, вы не смогли бы передать в неё Dog или любой другой подкласс Animal. Это бы значительно повысило вероятность ошибок, так как в некоторых случаях использование более специфичных типов помогает обеспечить, что определённые методы или свойства доступны.

  - `Сложности с объединениями`: Если бы классы и объекты были инвариантными, работа с объединениями была бы усложнена. Например, обработка различных типов, которые могут быть переданы в функцию, стала бы более сложной и менее читаемой, что потребовало бы дополнительных проверок типов и усложнила бы код.

- Влияние на удобство разработки

  - `Комплексность дизайна`: В разработке часто используются шаблоны проектирования, которые полагаются на наследование и полиморфизм. Если бы классы были инвариантными, это усложнило бы проектирование интерфейсов и классов, так как добавление новых типов или расширение существующих функций стало бы более трудоемким.

  - `Потеря возможности обобщенных функций`: В TypeScript поддерживаются обобщения, которые позволяют создавать функции и классы, работающие с разными типами данных. Из-за инвариантности разработчики не смогли бы воспользоваться преимуществами обобщений, что снизило бы переиспользование кода и абстракцию, ведь некоторые функции могли бы работать только с конкретными типами.

  - `Проблемы с сторонними библиотеками`: Много библиотек используют наследование и полиморфизм. Инвариантность классов сделала бы интеграцию с такими библиотеками сложнее, так как разработчики не могли бы безопасно использовать специфичные реализаций в ожидании более общих интерфейсов.

> Инвариантность объектов и классов в TypeScript сделала бы язык менее гибким и более строгим, что могло бы привести к увеличению количества ошибок типов и усложнению процесса разработки. Гибкость, которую предоставляет ковариантность и контравариантность, в совокупности обеспечивает лучшую безопасность типов и более удобную работу с великими возможностями, которые предлагает TypeScript.

[Вернуться к началу статьи](#typescript)

---

## Type Widening

> `Type Widening` в TypeScript — это механизм, который автоматически изменяет тип переменной на более общий (или "широкий") тип в определённых ситуациях. Это происходит, когда компилятор не может точно определить тип переменной на момент ее создания.

- Как работает Type Widening

  - `Присваивание значения`: Если вы объявляете переменную без явного указания типа и присваиваете ей значение, TypeScript пытается вывести наиболее конкретный тип для этой переменной. Если переменная не объявлена с конкретным типом или если она изменяется, TypeScript может сделать её более широкой.

  - `Условия и ветвления`: Когда переменную определяют в одном ветвлении условия, а затем используют в другом, TypeScript может сделать её тип более общим.

1. `Пример с примитивами`:

```typescript
let myVariable = 'hello' // myVariable имеет тип "string"

myVariable = 10 // Это вызовет ошибку, потому что myVariable объявлена как 'string',
// и тип стал более узким. Если бы переменная была определена как let myVariable: string | number, то она "расширяется" до типа, который включает оба значения.
```

2. `Пример с массивами`:

```typescript
let myList = [1, 2, 3] // myList имеет тип number[]

myList.push('hello') // Это вызовет ошибку, потому что здесь предполагается массив чисел.
// Если бы вы присвоили let myList: (number | string)[], вы могли бы добавлять как числа, так и строки, и TypeScript бы позволил это.
```

3. `Пример с условиями`:

```typescript
let value

if (Math.random() > 0.5) {
	value = 'Hello' // TypeScript считывает, что value может быть string
} else {
	value = 10 // Теперь value может быть number
}

// В этом случае value будет иметь тип "string | number", так как были разные типы присвоены.
```

### Как этот механизм Type Widening влияет на type safety в TS?

> Type Widening в TypeScript имеет значительное влияние на типовую безопасность (type safety) проекта, и вот как это происходит:

1. `Повышение гибкости`

- Type Widening позволяет разработчикам использовать более общие типы, что делает код более гибким и динамичным. Это позволяет избежать излишнего указания типов, особенно когда тип переменной может изменяться в зависимости от условий. Однако такая гибкость может привести к ситуации, когда переменные могут принимать неожиданные значения, что может влиять на стабильность кода.

2. `Уменьшение ошибок`

- В случаях, когда Type Widening происходит, TypeScript автоматически обеспечивает, что переменная не будет использоваться в контексте, который не соответствует её новому более широкому типу. Например, если переменная, изначально определенная как string, затем получает значение number, TypeScript будет ограничивать использование этой переменной только типами, которые соответствуют string | number. Это помогает предотвратить ошибки, которые могут возникнуть при неправильном использовании переменной.

3. `Усложнение понимания кода`

- Поскольку Widening может сделать переменные более общими, это иногда затрудняет понимание кода. Разработчики должны вникать в логику и возможно, несколько ветвлений условий, чтобы понять, какие типы может принимать каждая переменная. Это может привести к состоянию, когда код становится менее читаемым и более сложным для сопровождения.

4. `Риск потери типовой информации`

- Type Widening может приводить к ситуации, когда вы теряете информацию о конкретном типе. Если переменная, которую вы ожидаете использовать только с определенным типом данных, "расширяется" до более общего типа, это может привести к логическим ошибкам в коде. Например, если функция ожидает только строки, а переменная расшифровывается как string | number, это может привести к сбоям или нежелательному поведению в выполнении программы.

[Вернуться к началу статьи](#typescript)

---

## Fresh object literal type

> `Fresh object literal type` в TypeScript — это новый тип, который создается при использовании литераля объекта, и он имеет уникальный тип, отличающийся от других объектов. Каждый раз, когда вы определяете литерал объекта в коде, TypeScript создает новый и уникальный тип для этого литерала, а не использует уже существующий тип. Это может быть очень полезно для обеспечения строгой типизации и минимизации ошибок.

```typescript
const obj1 = { name: 'Alice', age: 30 }
const obj2 = { name: 'Bob', age: 25 }

// obj1 и obj2 имеют разные типы, даже если их структура идентична
```

> Хотя obj1 и obj2 имеют одинаковую структуру, TypeScript рассматривать их как разные типы. Это называется "fresh object literal type", и оно помогает избежать смешивания различных экземпляров объектов и сохраняет четкость в типах.

Применение

- `Типизация функции`: Если вы передаете объект в функцию, ожидающие тип, вы можете использовать fresh object literal type, чтобы гарантировать, что переданный объект имеет тип, соответствующий именно этому экземпляру.

```typescript
function printPerson(person: { name: string; age: number }) {
	console.log(`${person.name}, ${person.age} years old`)
}

printPerson(obj1) // Работает
printPerson(obj2) // Работает
```

- `Контекстное разбиение`: Поскольку каждый литерал представляет уникальный тип, это позволяет избежать ситуаций, когда в одном месте используется одна структура, а в другом другая, тем самым сохраняя целостность и предсказуемость типов.

> `Excess property checking` в TypeScript активируется для `fresh object literal types`, чтобы гарантировать, что объект не содержит лишних свойств, которые не определены в ожидаемом типе. Это особенно важно, когда вы передаете объект как аргумент в функции или присваиваете его переменной с определенным типом. Давайте рассмотрим, почему это происходит:

Причины включения excess property checking

- `Безопасность типов`: Когда вы используете литерал объекта в TypeScript, вы можете непреднамеренно добавить дополнительные свойства, которые не соответствуют ожидаемым. Excess property checking помогает предотвратить такие ошибки на этапе компиляции, делая код более безопасным.

```typescript
interface Person {
	name: string
	age: number
}

const person = { name: 'Alice', age: 30, height: 170 } // Ошибка: 'height' не существует в типе 'Person'
```

- `Избавление от неопределенности`: Когда TypeScript рассматривает fresh object literal type, он знает, что это новый уникальный тип, созданный прямо сейчас. Это значит, что он не должен допускать наличие свойств, которые не были явным образом определены в типе. Это позволяет избежать ситуации, когда у вас могут быть неопределенные или неожиданные свойства в объекте.

- `Согласованность типов`: Excess property checking обеспечивает согласованность между тем, что вы ожидаете получить от объекта, и тем, что действительно передается. Это особенно полезно в больших проектах, где масштабируемость и понимание кода критически важны.

Пример

```typescript
interface Person {
	name: string
	age: number
}

// Литерал объекта, содержащий лишнее свойство 'height'
const person: Person = { name: 'Bob', age: 25, height: 180 } // Ошибка: лишнее свойство 'height'

// Правильный объект
const validPerson: Person = { name: 'Bob', age: 25 } // Работает
```

> В этом случае TypeScript выдает ошибку, так как литерал объекта содержит свойство height, которое не определено в интерфейсе Person. Это помогает вам убедиться, что ваш объект соответствует ожидаемой структуре, избегая неожиданных ошибок выполнения.

> Передача литерала объекта напрямую в функцию, а не через промежуточное присваивание переменной, может уменьшить вероятность ошибок в некоторых случаях. Давайте разберем, почему это происходит и как это связано с TypeScript.

Причины, по которым прямой вызов может уменьшить вероятность ошибок:

- `Проверка лишних свойств`: Когда вы передаете литерал объекта напрямую в функцию, TypeScript применяет проверку лишних свойств к этому объекту. Если в объекте есть свойства, которые отсутствуют в указанном типе, вы получите ошибку компиляции.

```typescript
interface Person {
	name: string
	age: number
}

function greet(person: Person) {
	console.log(`Hello, ${person.name}`)
}

greet({ name: 'Alice', age: 30, height: 170 }) // Ошибка: 'height' не существует в типе 'Person'
```

Если же вы сначала присваиваете литерал объекту, компилятор может не работать так же строго:

```typescript
const individual = { name: 'Alice', age: 30, height: 170 } // Ошибки нет
greet(individual) // Ошибка не возникает
```

- `Неявное преобразование типов`: Когда вы присваиваете литерал объекта переменной, TypeScript может не применять строгую проверку типов. Это может привести к ситуации, когда вы случайно передаете объект с лишними свойствами или с несовпадающими типами.

- `Потеря контекста`: При промежуточном присваивании может быть легко потерять контекст нужного типа. Например, если вы измените объект после его создания и передадите его в функцию, вы можете случайно добавить лишние свойства или изменить существующие:

```typescript
const person = { name: 'Bob', age: 25 }
// Позже вы добавляете свойство
person.height = 180 // Теперь у вас объект некорректен
greet(person) // Ошибка не показывается заранее
```

- `Более сложные структуры`: Если объект имеет более сложную структуру или вложенные объекты, промежуточные присваивания могут привести к более глубоким проблемам, поскольку в каждом шаге есть риск изменения структуры:

```typescript
const user = {
	name: 'Charlie',
	age: 28,
	address: {
		city: 'New York',
	},
}

user.address.zipCode = 10001 // Это может привести к проблемам в зависимости от ожидаемого типа
```

[Вернуться к началу статьи](#typescript)

---

## Refinement

> `Refinement в TypeScript` — это процесс, который позволяет уточнить тип переменной на более узкий или конкретный. Обычно это происходит в результате проверки условий или использования операторов типа, таких как typeof, instanceof и другие. Это помогает избежать ошибок типов и делает код более безопасным и понятным.

> Например, если у вас есть переменная, которая может быть либо строкой, либо числом, вы можете использовать typeof для проверки её типа и "уточнения" этого типа в определенном контексте:

```typescript
function example(value: string | number) {
	if (typeof value === 'string') {
		// Здесь TypeScript знает, что value - это строка
		console.log(value.toUpperCase()) // Можно безопасно вызывать методы строк
	} else {
		// Здесь TypeScript знает, что value - это число
		console.log(value.toFixed(2)) // Можно безопасно вызывать методы чисел
	}
}
```

> `Refinement` в контексте TypeScript и `Discriminated Unions` — это механизм, который позволяет использовать свойства объектов для определения их точного типа. Discriminated Unions (также известные как союзные типы) позволяют комбинировать несколько типов с помощью общего "дискриминатора" (обычно это свойство, которое есть у всех объединенных типов). Refinement позволяет проверить это свойство и уточнить тип на основе его значения.

Пример Discriminated Unions с Refinement.
Рассмотрим пример, где у нас есть несколько типов фигур, и каждая фигура имеет общий дискриминатор type:

```typescript
interface Circle {
	kind: 'circle'
	radius: number
}

interface Square {
	kind: 'square'
	sideLength: number
}

type Shape = Circle | Square

function calculateArea(shape: Shape) {
	if (shape.kind === 'circle') {
		// Здесь TypeScript знает, что shape - это Circle
		return Math.PI * shape.radius ** 2
	} else {
		// Здесь TypeScript знает, что shape - это Square
		return shape.sideLength ** 2
	}
}
```

Как это работает:

- `Дискриминатор`: Каждая фигура имеет свойство `kind`, которое служит дискриминатором. Это свойство позволяет отличить разные типы объектов внутри объединения.

- `Refinement`: Когда мы проверяем `shape.kind`, TypeScript использует эту проверку, чтобы "уточнить" тип `shape` на основе значения `kind`. Внутри блока if (где `shape.kind` === `circle`) TypeScript понимает, что shape — это `Circle`, и выдает ошибки, если вы попытаетесь использовать методы или свойства, которые специфичны для `Square`.

- `Безопасность типов`: Этот подход улучшает безопасность типов в коде. Вы можете быть уверены, что используете только те свойства и методы, которые доступны для конкретного типа объекта, и избегать ошибок во время выполнения

> Использование `generic` переменных в тегах для `Discriminated Unions` может сделать программу более склонной к багам по нескольким причинам.

Почему это может привести к багам:

- `Сложность типов`: Когда вы используете generics в качестве тегов, это может усложнить систему типов. Обычно дискриминирующие теги представляют конкретные значения (например, строковые литералы), которые легче интерпретировать и проверять. Generics могут позволить использовать более широкий диапазон значений, что увеличивает вероятность ошибок при их использовании.

- `Неявные зависимости`: Если типы объединяются с использованием generics, могут возникнуть неявные зависимости между ними. Это может привести к ошибкам, когда один тип ожидает другой тип, но это неочевидно из кода.

- `Недостаточная безопасность типов`: Типы, определенные с generics, могут быть слишком обобщенными. Например, если тег использует generic тип T, это может позволить создавать объекты, которые не соответствуют предполагаемым структурам, что в свою очередь может привести к ошибкам на этапе выполнения.

Когда это действительно приводит к багам:

- `Сложные структуры`: Если ваша программа имеет много уровней вложенности или сложные структуры данных на основе generics, это может сделать отладку и понимание кода более трудоемкими и склонными к ошибкам.

- `Работа с промежуточными значениями`: Если вы используете generics для определения промежуточных значений, это может привести к несоответствию типов в различных частях кода. Например, если функция возвращает тип, основанный на generic переменной, а другой код ожидает конкретный тип, это может вызвать ошибки.

Когда это не приводит к багам:

- `Однозначные значения`: Если вы используете generics в контексте, где значения четко определены и имеют ограниченное количество возможных вариантов, это может работать хорошо. Например, использование generic для описания API-ответов, когда вы четко знаете, как должен выглядеть ответ.

- `Тестирование и валидация` : Если вы используете строгие тесты и валидацию на уровне типов, это может помочь вам обнаружить ошибки, возникшие из-за неправильного использования generics на этапе компиляции.

Пример

```typescript
interface Shape<T> {
	kind: T
	data: string
}

type Circle = Shape<'circle'>
type Square = Shape<'square'>

type Shapes = Circle | Square

function handleShape(shape: Shapes) {
	switch (shape.kind) {
		case 'circle':
			console.log(`Circle with data: ${shape.data}`)
			break
		case 'square':
			console.log(`Square with data: ${shape.data}`)
			break
		default:
			// Здесь TypeScript не может гарантировать, что мы обработали все случаи
			const _exhaustiveCheck: never = shape
			throw new Error('Unexpected shape')
	}
}
```

> В этом примере использование строковых литералов в качестве тегов упрощает понимание и обработку типов, а использование generics могло бы привести к непредсказуемым ошибкам

[Вернуться к началу статьи](#typescript)

---

## Companion Object Pattern

> `Companion Object Pattern` в TypeScript не является частью языка по умолчанию, как это реализовано в Kotlin, но можно создать аналогичную концепцию, используя комбинацию классов и статических членов. Companion Object в Kotlin позволяет создавать статические методы и свойства, связанные с классом, и доступ к ним осуществляется без создания экземпляра класса. В TypeScript вы можете добиться схожей функциональности, создавая статические методы и свойства внутри класса.

Применение Companion Object Pattern в TypeScript.

```typescript
class MyClass {
	private constructor() {}

	public static create(): MyClass {
		return new MyClass()
	}

	public static sayHello(): string {
		return 'Hello from MyClass!'
	}
}

// Использование
const instance = MyClass.create()
console.log(MyClass.sayHello()) // "Hello from MyClass!"
```

### Declaration Merging в TypeScript

> `Declaration Merging` позволяет объединять несколько деклараций с одинаковым именем в одну. Это может быть полезно, например, для расширения интерфейсов или добавления новых свойств к классам. Вы можете использовать Declaration Merging для добавления статических методов или свойств к классу.

```typescript
class MyClass {
	private constructor() {}

	public static create(): MyClass {
		return new MyClass()
	}
}

// Расширение класса с помощью Declaration Merging
interface MyClass {
	newProperty: string
}

MyClass.newProperty = 'This is a new property'

// Использование
const instance = MyClass.create()
console.log(MyClass.newProperty) // "This is a new property"
```

> Таким образом, хотя TypeScript не поддерживает `Companion Object` так, как это делает Kotlin, вы все равно можете реализовать аналогичное поведение с помощью статических методов/свойств и использования Declaration Merging. Это позволяет организовать код и обращаться к функциональности класса без необходимости создавать его экземпляр.

[Вернуться к началу статьи](#typescript)

---

## Type output in TypeScript

> Вывод типов `Type Inference` в TypeScript — это механизм, который позволяет компилятору автоматически определять тип переменной, функции или выражения, основанный на его значении или контексте. Это особенно полезно, так как позволяет программистам не указывать типы явно, сокращая код и делая его более читабельным.

> Когда TypeScript видит присвоение значения переменной, он анализирует это значение и, если может его определить, задает тип переменной автоматически:

```typescript
let message = 'Hello, World!' // TypeScript выводит тип как string
let count = 42 // TypeScript выводит тип как number
```

> Если переменная не инициализирована, TypeScript может вывести тип из контекста, например, в функции:

```typescript
function add(a: number, b: number) {
	return a + b // Возвращаемый тип выводится как number
}
```

### Типичные проблемы вывода типов в TypeScript

1. `Неявный вывод типа any`: Если TypeScript не может вывести тип переменной, он присваивает ей тип any, что нарушает типизацию. Это обычно происходит в динамических ситуациях.

```typescript
let x // Тип выводится как any
x = 5 // x теперь может быть чем угодно
```

2. `Несоответствие типов`: При выводе типов в некоторых случаях TypeScript может принять неверное решение о типе, что приводит к ошибкам во время выполнения.

```typescript
let value = Math.random() > 0.5 ? 'string' : 10 // value имеет тип string | number
let result = value * 2 // Ошибка, если value - строка
```

3. `Уточнение типов`: Если вас интересует более строгая типизация, то TypeScript может не всегда корректно определить тип в условиях проверки, что требует дополнительных проверок или утверждений.

```typescript
function handle(value: number | string) {
	if (typeof value === 'string') {
		console.log(value.length) // Правильно
	}
	console.log(value * 2) // Ошибка, value мог быть строкой
}
```

### Типы, которые может выводить TypeScript

- number
- string
- boolean
- object
- undefined
- null
- any
- void
- never
- массивы (например, number[])
- кортежи
- объединения (например, string | number)
- пересечения (например, A & B)

> TypeScript также поддерживает более сложные структуры, такие как интерфейсы и классы, которые также могут быть выведены на основе контекста.

[Вернуться к началу статьи](#typescript)

---

## Polymorphism in TypeScript

> `Полиморфизм в TypeScript` — это принцип, позволяющий использовать один интерфейс для работы с различными типами данных. TypeScript поддерживает несколько видов полиморфизма, включая:

1. Полиморфизм в функциях

- Функции могут принимать параметры разных типов, используя обобщения (generics). Это позволяет писать функции, которые работают с различными типами данных, обеспечивая типобезопасность.

```typescript
function identity<T>(arg: T): T {
	return arg
}

let output1 = identity<string>('Hello, World!') // output1 имеет тип string
let output2 = identity<number>(42) // output2 имеет тип number
```

2. Полиморфизм интерфейсов

- Интерфейсы могут описывать методы и свойства, которые могут быть реализованы различными классами. Это позволяет использовать один и тот же интерфейс для разных классов.

```typescript
interface Shape {
	area(): number
}

class Circle implements Shape {
	constructor(private radius: number) {}
	area() {
		return Math.PI * this.radius * this.radius
	}
}

class Rectangle implements Shape {
	constructor(private width: number, private height: number) {}
	area() {
		return this.width * this.height
	}
}

const shapes: Shape[] = [new Circle(5), new Rectangle(10, 20)]
shapes.forEach(shape => console.log(shape.area()))
```

3. Полиморфизм через наследование

- Классы в TypeScript могут наследоваться друг от друга, что позволяет переопределять методы базового класса в производном классе. Это также является примером полиморфизма.

```typescript
class Animal {
	makeSound(): void {
		console.log('Some sound')
	}
}

class Dog extends Animal {
	makeSound(): void {
		console.log('Woof!')
	}
}

class Cat extends Animal {
	makeSound(): void {
		console.log('Meow!')
	}
}

const animals: Animal[] = [new Dog(), new Cat()]
animals.forEach(animal => animal.makeSound()) // Вызовет "Woof!" и "Meow!"
```

4. Полиморфизм с использованием объединений

- Вы можете использовать объединения для создания функций, которые могут принимать различные типы, и выполнять разные действия в зависимости от переданного типа.

```typescript
function print(value: string | number) {
	if (typeof value === 'string') {
		console.log('String: ' + value)
	} else {
		console.log('Number: ' + value)
	}
}

print('Hello!') // Выведет "String: Hello!"
print(100) // Выведет "Number: 100"
```

[Вернуться к началу статьи](#typescript)

---
